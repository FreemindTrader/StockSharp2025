using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Drawing;
using fx.Definitions;
using fx.Common;
using StockSharp.BusinessEntities;
using fx.Collections;
using fx.Bars;
using System.Threading.Tasks;
using System.Threading;

namespace fx.Algorithm
{
    /// <summary>
    /// Base class for all technical trading indicators implementations (like MA, MACD, EMA, RSI etc.). Note that one
    /// mathematics indicator algorythm (for ex. RSI) can have multiple implementations in multiple classes (for ex.
    /// RSI1, RSI2, RSIEx etc.). IndicatorsUnsafe are separated in two main types - tradeable indicators produce results
    /// and signals in a consistent way, by using only information from the past periods - non tradeable indicators use
    /// information that may not be available in a normal typical trading environment (like for ex. bars from the
    /// future) If you are using an indicator for a trading strategy testing, make sure it is actually Tradeable.
    /// </summary>
    [Serializable]
    public abstract class Indicator : IMyIndicator, IDeserializationCallback, IDisposable
    {
        protected IndicatorResults _results;

        /// <summary>
        /// Results generated by this indicator.
        /// </summary>
        public IndicatorResults IndicatorResult
        {
            get
            {
                if( this.Enabled == false )
                {
                    return null;
                }

                // Results has thread safety integrated.
                return _results;
            }
        }

        private CancellationTokenSource _exitSource;

        public CancellationTokenSource IndicatorExitTokenSource
        {
            get
            {
                return _exitSource;
            }

            set
            {
                _exitSource = value;
            }
        }

        public CancellationToken IndicatorExitToken
        {
            get
            {
                return _exitSource == null ? GeneralHelper.GlobalExitToken() : _exitSource.Token;
            }
        }

        //private StrategySession _parentSession;

        //public StrategySession ParentSession
        //{
        //    get
        //    {
        //        return _parentSession;
        //    }

        //    set
        //    {
        //        _parentSession = value;
        //    }

        //}

        protected IndicatorSignals _signals;

        protected bool _useAsyncCall = false;

        /// <summary>
        /// Signals generated by this indicator (signals are usually processed from results and present an interpreted
        /// version of the resuls, suitable for futher automated processing)
        /// </summary>
        public IndicatorSignals Signals
        {
            get
            {
                if( this.Enabled == false )
                {
                    return null;
                }
                // Signals has thread safety integrated.
                return _signals;
            }
        }

        public int BarsFromLastCross
        {
            get
            {
                lock( this )
                {
                    return Bars.TotalBarCount - Signals.LastSignalIndex;
                }
            }
        }

        protected IndicatorParameters _parameters;

        /// <summary>
        /// Provides dynamic access to any type of indicator parameters. Needed, since some indicators are accessible
        /// only trough management classes, and effectively share the same class, with their separate instances.
        /// </summary>
        public IndicatorParameters TaIndicatorParameters
        {
            get
            {
                // TaIndicatorParameters has thread safety integrated.
                return _parameters;
            }
        }

        [NonSerialized] private fxHistoricBarsRepo _indicatorBarsRepo;

        /// <summary>
        /// The data provider used by the indicator.
        /// </summary>
        public fxHistoricBarsRepo Bars
        {
            get
            {
                return _indicatorBarsRepo;
            }
        }        

        protected Security _indicatorSecurity;
        protected double _instrumentPointSize = 0;
        protected int _instrumentDigits = 0;

        /// <summary>
        /// Is the indicator initialized.
        /// </summary>
        public bool Initialized
        {
            get
            {
                return _indicatorBarsRepo != null;
            }
        }

        protected volatile string _name = string.Empty;

        /// <summary>
        /// The name of the indicator.
        /// </summary>
        public string Name
        {
            get
            {
                return _name;
            }
            
        }

        protected volatile string _description = string.Empty;

        /// <summary>
        /// A description of this indicator.
        /// </summary>
        public string Description
        {
            get
            {
                return _description;
            }
        }

        private volatile bool _isIndicatorVisible = true;

        public bool IndicatorVisible
        {
            get
            {
                return _isIndicatorVisible;
            }
        }

        private volatile bool _enabled = true;

        /// <summary>
        /// Is the indicator enabled.
        /// </summary>
        public bool Enabled
        {
            get
            {
                return _enabled;
            }
        }

        private bool? _tradeable;

        /// <summary>
        /// Null value here means - do not know.
        /// </summary>
        public bool? Tradeable
        {
            get
            {
                return _tradeable;
            }
        }

        private bool? _showInMasterPane;

        /// <summary>
        /// Null value here means = do not know.
        /// </summary>
        public bool? ShowInMasterPane
        {
            get
            {
                return _showInMasterPane;
            }
        }

        private PooledDictionary< string, Color > _customMessages = null;

        /// <summary>
        /// A set of additional output message of this indicator to the user.
        /// </summary>
        public PooledDictionary< string, Color > CustomMessages
        {
            get
            {
                return _customMessages;
            }
            set
            {
                _customMessages = value;
            }
        }

        private bool _isUnstable = false;

        /// <summary>
        /// Unstable indicatos calculate their current value based on *all* the previously calculated values; thus their
        /// effective lookback is changing and growing all the time.
        /// </summary>
        public bool IsUnstable
        {
            get
            {
                return _isUnstable;
            }
        }

        public int IndicatorCounted
        {
            get
            {
                return IndicatorResult.SetLength;
            }
        }

        

/// <summary>
/// Event fires when indicator has been calculated.
/// </summary>

        public event EventHandler< HistoricBarsUpdateEventArg > IndicatorCalculatedEvent;
        public event EventHandler< HistoricBarsUpdateEventArg > FullCalculationDoneEvent;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">
        /// Pass null or empty to use the UserFriendly name attribute (applicable for custom indicators, not to
        /// GenericTaLib ones).
        /// </param>
        /// <param name="isIndicatorVisible"></param>
        /// <param name="isTradeable"></param>
        /// <param name="isShowInMasterPane">
        /// Is the indicator the same number scale as quote dataSource (for ex. a same scaled indicator is a MA
        /// indicator, and a RSI is not)
        /// </param>
        public Indicator( string name, bool isIndicatorVisible, bool? isTradeable, bool? isShowInMasterPane, string[ ] resultSetNames )
        {
            _name = name;

            if( string.IsNullOrEmpty( _name ) )
            {
                _name = GetUserFriendlyName( );
            }

            _tradeable          = isTradeable;
            _showInMasterPane   = isShowInMasterPane;
            _isIndicatorVisible = isIndicatorVisible;
            _results            = new IndicatorResults( this, resultSetNames );
            _signals            = new IndicatorSignals( this );
            _parameters         = new IndicatorParameters( );
        }

        public virtual void Dispose( )
        {
            UnInitialize( );
            _indicatorBarsRepo = null;
        }

        #region IDeserializationCallback Members

        public virtual void OnDeserialization( object sender )
        {
        }

        public virtual void HandleDynamicParametersUpdate( string name, object value )
        {
        }

        #endregion

        public virtual bool AttachDatasource( IHistoricBarsRepo dataProvider )
        {
            OnInitialize( );

            lock( this )
            {
                _indicatorBarsRepo = ( fxHistoricBarsRepo ) dataProvider;

                _indicatorSecurity = dataProvider.Security;

                _instrumentPointSize = _indicatorSecurity.PriceStep.HasValue ? ( double ) _indicatorSecurity.PriceStep.Value : 1;
                _instrumentDigits = _indicatorSecurity.Decimals.HasValue ? ( int ) _indicatorSecurity.Decimals.Value : 5;

                _results = new IndicatorResults( this, _results.SetsNamesList.ToArray( ), FinancialHelper.CalculateStorageSize( _indicatorBarsRepo.Period.Value ) );

                if( _indicatorBarsRepo != null )
                {
                    _indicatorBarsRepo.HistoricBarUpdateEvent += Indicator_OnHistoricBarsUpdateEvent; ;                    
                }

                if( _parameters != null )
                {
                    _parameters.IndicatorParameterUpdatedEvent += new IndicatorParameters.ParameterUpdatedValueDelegate( Indicator_ParameterUpdatedValueEvent );
                }
            }

            return true;
        }

        

        protected virtual void OnInitialize( )
        {
        }

        public virtual void UnInitialize( )
        {
            lock( this )
            {
                if( _indicatorBarsRepo != null )
                {
                    if( _indicatorBarsRepo != null )
                    {
                        _indicatorBarsRepo.HistoricBarUpdateEvent -= Indicator_OnHistoricBarsUpdateEvent;                        
                    }
                    _indicatorBarsRepo = null;
                }

                if( _parameters != null )
                {
                    _parameters.IndicatorParameterUpdatedEvent -= new IndicatorParameters.ParameterUpdatedValueDelegate( Indicator_ParameterUpdatedValueEvent );
                }
            }
        }

        protected int ArrayInitialize( ref double[ , ] inputArrary, double value )
        {
            lock( this )
            {
                for( int i = 0; i < inputArrary.GetLength( 0 ); i++ )
                {
                    for( int j = 0; j < inputArrary.GetLength( 1 ); j++ )
                    {
                        inputArrary[ i, j ] = value;
                    }
                }
            }

            return ( inputArrary.GetLength( 0 ) * inputArrary.GetLength( 1 ) );
        }

        protected int ArrayInitialize( out PooledList< double > inputArrary, double value )
        {
            lock( this )
            {
                inputArrary = new PooledList< double >( Bars.TotalBarCount );

                for( int i = 0; i < inputArrary.Count; i++ )
                {
                    inputArrary[ i ] = value;
                }
            }

            return inputArrary.Count;
        }

        protected int ArrayInitialize( out PooledList< bool > inputArrary, bool value )
        {
            lock( this )
            {
                inputArrary = new PooledList< bool >( Bars.TotalBarCount );

                for( int i = 0; i < inputArrary.Count; i++ )
                {
                    inputArrary[ i ] = value;
                }
            }

            return inputArrary.Count;
        }

        protected int ArrayInitialize( ref bool[ ] inputArrary, bool value )
        {
            lock( this )
            {
                for( int i = 0; i < inputArrary.Length; i++ )
                {
                    inputArrary[ i ] = value;
                }
            }

            return inputArrary.Length;
        }

        private void Indicator_ParameterUpdatedValueEvent( string name, object value )
        {
            // Tony Lam: This is invoked from the UI thread. So it is better we start a thread to process the request.

            if( !StartPerformingLongCalculationTask( name, value ) )
            {
                FreemindCalculateIndicators( true, new HistoricBarsUpdateEventArg( DataBarUpdateType.Initial, 0, _indicatorBarsRepo.TotalBarCount ) );
            }
        }

        public virtual bool StartPerformingLongCalculationTask( string name, object value )
        {
            return false;
        }

        //public virtual bool PerformFullCalculationTask( DoneReloadDatabars update )
        //{
        //    return false;
        //}

        /// <summary>
        /// Child classes must be marked with UserFriendlyAttribute, to provide user friendly name.
        /// </summary>
        /// <returns></returns>
        public string GetUserFriendlyName( )
        {
            string name = this.GetType( ).Name;
            UserFriendlyNameAttribute.GetTypeAttributeValue( this.GetType( ), ref name );

            return name;
        }

        public void FreemindCalculateIndicators( bool fullRecalculation, HistoricBarsUpdateEventArg e )
        {
            if( this.Initialized == false || this.Enabled == false )
            {
                return;
            }

            if( _indicatorBarsRepo.TotalBarCount == 0 )
            {
                return;
            }

            var updateType = e?.UpdateType;

            if( fullRecalculation )
            {
                updateType = DataBarUpdateType.Initial;
            }

            switch( updateType )
            {
                case DataBarUpdateType.Initial:
                    OnInitialDataBarUpdatePreCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.CurrentBarUpdate:
                    OnCurrentBarUpdatePreCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.HistoryUpdate:
                    OnHistoryBarUpdatePreCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.NewPeriod:
                    OnNewBarArrivesPreCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.Reloaded:
                    OnDataBarsReloadedPreCalculation( fullRecalculation );
                    break;
            }

            // For both Initial and Reloaded, we are calling OnCalculate Asynchronously 
            switch( updateType )
            {
                case DataBarUpdateType.Initial:
                case DataBarUpdateType.CurrentBarUpdate:
                case DataBarUpdateType.HistoryUpdate:
                case DataBarUpdateType.NewPeriod:
                case DataBarUpdateType.Reloaded:
                {
                    OnCalculate( fullRecalculation, e );
                }
                    break;
            }

            switch( updateType )
            {
                case DataBarUpdateType.Initial:
                    OnInitialDataBarUpdatePostCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.CurrentBarUpdate:
                    OnCurrentBarUpdatePostCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.HistoryUpdate:
                    OnHistoryBarUpdatePostCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.NewPeriod:
                    OnNewBarArrivesPostCalculation( fullRecalculation );
                    break;

                case DataBarUpdateType.Reloaded:
                    OnDataBarsReloadedPostCalculation( fullRecalculation );
                    break;
            }

            OnFinalCalculate( fullRecalculation, updateType );

            if( IndicatorCalculatedEvent != null )
            {
                IndicatorCalculatedEvent( this, e );
            }
        }

        /// <summary>
        /// Calculation helper function.
        /// </summary>
        //public void CalculateIndicators( bool fullRecalculation, DataBarUpdateType? updateType )
        //{
        //    if( _useAsyncCall )
        //    {
        //        FreemindCalculateIndicators( fullRecalculation, updateType );
        //    }
        //    else
        //    {
        //        if( this.Initialized == false || this.Enabled == false )
        //        {
        //            return;
        //        }

        //        if( _historicBarsRepo.TotalBarCount == 0 )
        //        {
        //            return;
        //        }

        //        if( fullRecalculation && !updateType.HasValue )
        //        {
        //            updateType = DataBarUpdateType.Initial;
        //        }

        //        switch( updateType )
        //        {
        //            case DataBarUpdateType.Initial:
        //                OnInitialDataBarUpdatePreCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.CurrentBarUpdate:
        //                OnCurrentBarUpdatePreCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.HistoryUpdate:
        //                OnHistoryBarUpdatePreCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.NewPeriod:
        //                OnNewBarArrivesPreCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.Reloaded:
        //                OnDataBarsReloadedPreCalculation( fullRecalculation );
        //                break;
        //        }

        //        OnCalculate( fullRecalculation, updateType );

        //        switch( updateType )
        //        {
        //            case DataBarUpdateType.Initial:
        //                OnInitialDataBarUpdatePostCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.CurrentBarUpdate:
        //                OnCurrentBarUpdatePostCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.HistoryUpdate:
        //                OnHistoryBarUpdatePostCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.NewPeriod:
        //                OnNewBarArrivesPostCalculation( fullRecalculation );
        //                break;

        //            case DataBarUpdateType.Reloaded:
        //                OnDataBarsReloadedPostCalculation( fullRecalculation );
        //                break;
        //        }

        //        OnFinalCalculate( fullRecalculation, updateType );

        //        if( IndicatorCalculatedEvent != null )
        //        {
        //            IndicatorCalculatedEvent( this, fullRecalculation );
        //        }
        //    }
        //}

        public virtual void OnInitialDataBarUpdatePostCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnCurrentBarUpdatePostCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnHistoryBarUpdatePostCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnNewBarArrivesPreCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnInitialDataBarUpdatePreCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnDataBarsReloadedPreCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnDataBarsReloadedPostCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnCurrentBarUpdatePreCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnHistoryBarUpdatePreCalculation( bool fullRecalculation )
        {
            return;
        }

        public virtual void OnNewBarArrivesPostCalculation( bool fullRecalculation )
        {
            return;
        }

        /// <summary>
        /// Perform calculation on the given piece of dataSource.  Tony: I change the return type to int so we can minic
        /// Metatrader's IndicatorCounted() function.
        /// </summary>
        protected abstract void OnCalculate( bool fullRecalculation, HistoricBarsUpdateEventArg e );

        protected abstract void OnFinalCalculate( bool fullRecalculation, DataBarUpdateType? updateType );

        /// <summary>
        /// Line indeces always come from lower to biger.
        /// </summary>
        /// <param name="currentSignalPositionValue">
        /// This is what currently the value for this symbolPositionSummary is. Allows to handle multiple signals at a
        /// given place.
        /// </param>
        public virtual float OnResultAnalysisCrossingFound( int line1index, double line1value, int line2index, double line2value, bool direction, double currentPositionSignalValue )
        {
            return 0;
        }

        ///// <summary>
        ///// Line indeces always come from lower to biger.
        ///// </summary>
        ///// <param name="currentSignalPositionValue">This is what currently the value for this symbolPositionSummary is. Allows to handle multiple signals at a given place.</param>
        //virtual public float OnResultAnalysisExtremumFound(int lineIndex, double lineValue, bool extremumDirection, double currentPositionSignalValue)
        //{
        //    return 0;
        //}

        /// <summary>
        /// The child should return null in case it want no calculation to be done, or not inherit at all.
        /// </summary>
        /// <returns></returns>
        protected virtual double[ ][ ] ProvideSignalAnalysisLines( )
        {
            return null;
        }

        protected void RaiseFullCalculationDoneEvent( )
        {
            if( FullCalculationDoneEvent != null )
            {
                FullCalculationDoneEvent( this, new HistoricBarsUpdateEventArg( DataBarUpdateType.Initial, 0, _indicatorBarsRepo.TotalBarCount ) );
            }
        }

        #region Tony New Implementation

        // Since it is a null bar change, it can only be a CurrentBarUpdate or a NewPeriod formed.
        //public void CalculateOnlyNullBar( bool fullRecalculation, DataBarUpdateType? updateType )
        //{
        //    if( this.Initialized == false || this.Enabled == false )
        //    {
        //        return;
        //    }

        //    if( _indicatorBarsRepo.TotalBarCount == 0 )
        //    {
        //        return;
        //    }

        //    switch( updateType )
        //    {
        //        case DataBarUpdateType.CurrentBarUpdate:
        //            OnCurrentBarUpdatePreCalculation( fullRecalculation );
        //            break;

        //        case DataBarUpdateType.NewPeriod:
        //            OnNewBarArrivesPreCalculation( fullRecalculation );
        //            break;
        //    }

        //    // Calculate the indicator level lines.

        //    OnCalculate( fullRecalculation, updateType );

        //    switch( updateType )
        //    {
        //        case DataBarUpdateType.CurrentBarUpdate:
        //            OnCurrentBarUpdatePostCalculation( fullRecalculation );
        //            break;

        //        case DataBarUpdateType.NewPeriod:
        //            OnNewBarArrivesPostCalculation( fullRecalculation );
        //            break;
        //    }

        //    OnFinalCalculate( fullRecalculation, updateType );

        //    if( IndicatorCalculatedEvent != null )
        //    {
        //        IndicatorCalculatedEvent( this, fullRecalculation );
        //    }
        //}

        
        private void Indicator_OnHistoricBarsUpdateEvent( object sender, HistoricBarsUpdateEventArg e )
        {
            // If I do it in a thread which will take quite some time for the calcuation
            if ( e.UpdateType == DataBarUpdateType.Initial && e.UpdatedBarsCount > 200 )
            {
                Task detectTask = new Task(
                                            () =>
                                            {
                                                FreemindCalculateIndicators( e.UpdateType == DataBarUpdateType.Initial, e );

                                            }, IndicatorExitToken
                                        );

                detectTask.Start();
            }
            else
            {
                FreemindCalculateIndicators( e.UpdateType == DataBarUpdateType.Initial, e );
            }            
        }

        //private void PeriodXProvider_HistoricBarsReloadedEvent( fxHistoricBarsRepo provider, DataBarUpdateType updateType, int updatedBarsCount )
        //{
        //    FreemindCalculateIndicators( updateType == DataBarUpdateType.Initial, updateType );
        //}

        //private void Indicator_OnNullBarUpdateEvent( DataBarUpdateType updateType, IAskBidBar changedBar )
        //{
        //    CalculateOnlyNullBar( false, updateType );
        //}

        //private void PeriodXProvider_HistoricBarsReloadedEvent( fxHistoricBarsRepo provider, TimeSpan period, int updatedBarsCount )
        //{
        //    throw new NotImplementedException( );
        //}
        #endregion
    }
}