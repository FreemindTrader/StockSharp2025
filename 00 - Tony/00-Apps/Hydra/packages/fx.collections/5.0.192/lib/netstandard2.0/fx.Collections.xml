<?xml version="1.0"?>
<doc>
    <assembly>
        <name>fx.Collections</name>
    </assembly>
    <members>
        <member name="M:fx.Collections.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="T:fx.Collections.ClearMode">
            <summary>
            This enum allows control over how data is treated when internal
            arrays are returned to the ArrayPool. Be careful to understand 
            what each option does before using anything other than the default
            of Auto.
            </summary>
        </member>
        <member name="F:fx.Collections.ClearMode.Auto">
            <summary>
            <para><see cref="F:fx.Collections.ClearMode.Auto"/> has different behavior depending on the host project's target framework.</para>
            <para>.NET Standard 2.1, .NET Core 3: Reference types and value types that contain reference types are cleared
            when the internal arrays are returned to the pool. Value types that do not contain reference
            types are not cleared when returned to the pool.</para>
            <para>.NET Standard 2.0, .NET Framework: All user types are cleared before returning to the pool, in case they
            contain reference types.
            For .NET Standard, Auto and Always have the same behavior.</para>
            </summary>
        </member>
        <member name="F:fx.Collections.ClearMode.Always">
            <summary>
            <para>The <see cref="F:fx.Collections.ClearMode.Always"/> option has the effect of always clearing user types before returning to the pool.
            This is the default behavior on .NET Standard 2.0 and .NET Framework.</para><para>You might want to turn this on in a .NET Core project
            if you were concerned about sensitive data stored in value types leaking to other pars of your application.</para> 
            </summary>
        </member>
        <member name="F:fx.Collections.ClearMode.Never">
            <summary>
            <para><see cref="F:fx.Collections.ClearMode.Never"/> will cause pooled collections to never clear user types before returning them to the pool.</para>
            <para>You might want to use this setting in a .NET Core 3 or .NET Standard 2.1 project when you know that a particular collection stores
            only value types and you want the performance benefit of not taking time to reset array items to their default value.</para>
            <para>Be careful with this setting: if used for a collection that contains reference types, or value types that contain
            reference types, this setting could cause memory issues by making the garbage collector unable to clean up instances
            that are still being referenced by arrays sitting in the ArrayPool.</para>
            </summary>
        </member>
        <member name="M:fx.Collections.ClearModeUtil.ShouldClear``1(fx.Collections.ClearMode)">
            <summary>
            Implements the logic described for each case of the <see cref="T:fx.Collections.ClearMode"/> enum.
            </summary>
        </member>
        <member name="T:fx.Collections.BiDictionary`2">
            <summary>
            Implements a simple bi-directional dictionary (or a bi-map).
            </summary>
            <typeparam name="ValueType1"></typeparam>
            <typeparam name="ValueType2"></typeparam>
        </member>
        <member name="P:fx.Collections.BiDictionary`2.Item(`0)">
            <summary>
            [] accessor.
            </summary>
        </member>
        <member name="P:fx.Collections.BiDictionary`2.Count">
            <summary>
            Count of elements in collection.
            </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.Add(`0,`1)">
            <summary>
            Add element.
            </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByKey(`0)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByKeyNullabe(`0)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByKeySafe(`0,`1@)">
            <summary>
            Safe.
            </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByValue(`1)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.ContainsValue(`1)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.ContainsKey(`0)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByValueNullabe(`1)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.BiDictionary`2.GetByValueSafe(`1,`0@)">
            <summary>
            Safe.
            </summary>
        </member>
        <member name="M:fx.Collections.CircularList`1.#ctor(System.Int32)">
            <summary>
            Constructor that initializes the list with the required number of items.
            </summary>
        </member>
        <member name="P:fx.Collections.CircularList`1.Index">
            <summary>
            Returns the position of the circular list indexer.
            </summary>
        </member>
        <member name="P:fx.Collections.CircularList`1.Value">
            <summary>
            Gets/sets the item value at the current index.
            </summary>
        </member>
        <member name="P:fx.Collections.CircularList`1.Count">
            <summary>
            Returns the count of the number of loaded items, up to and including the total number of items in the
            collection.
            </summary>
        </member>
        <member name="P:fx.Collections.CircularList`1.Length">
            <summary>
            Returns the length of the items array.
            </summary>
        </member>
        <member name="P:fx.Collections.CircularList`1.Item(System.Int32)">
            <summary>
            Gets/sets the value at the specified index.
            </summary>
        </member>
        <member name="M:fx.Collections.CircularList`1.Next">
            <summary>
            Advances to the next item or wraps to the first item.
            </summary>
        </member>
        <member name="M:fx.Collections.CircularList`1.Clear">
            <summary>
            Clears the list, resetting the current index to the beginning of the list and flagging the collection as
            unloaded.
            </summary>
        </member>
        <member name="M:fx.Collections.CircularList`1.SetAll(`0)">
            <summary>
            Sets all items in the list to the specified value, resets the current index to the beginning of the list and
            flags the collection as loaded.
            </summary>
        </member>
        <member name="M:fx.Collections.CircularList`1.RangeCheck(System.Int32)">
            <summary>
            Internal indexer range check helper.  Throws ArgumentOutOfRange exception if the index is not valid.
            </summary>
        </member>
        <member name="T:fx.Collections.DiscardUnusedValueDelegate`2">
            <summary>
            Delegate used by ThreadSafe dictionaries on the GetOrCreateDiscardableValue methods.
            </summary>
        </member>
        <member name="T:fx.Collections.EmptyArray`1">
            <summary>
            Holds an immutable empty array that you can use everywhere if you need an empty array (so you avoid
            instantiating a new one everytime).
            </summary>
            <typeparam name="T">The type of the empty array this class holds.</typeparam>
        </member>
        <member name="P:fx.Collections.EmptyArray`1.Instance">
            <summary>
            Gets the empty array of type T.
            </summary>
        </member>
        <member name="T:fx.Collections.ForEachDictionaryDelegate`2">
            <summary>
            Delegate used by PfzDictionaries' ForEach method.
            </summary>
        </member>
        <member name="M:fx.Collections.FragmentableQueue`1.GetEnumerator">
            <summary>
            Gets an enumerator to Dequeue items from this queue.
            </summary>
        </member>
        <member name="T:fx.Collections.HotSwapDictionary`2">
            <summary>
            PooledDictionary implementing the hot swap model. Is a completely thread safe collection with lock-less read and very
            slow write operations.
            </summary>
            [DebuggerStepThrough]
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.AddRange(`0[],`1[])">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.TryAddValue(`0,`1)">
            <summary>
            Custom operation, performs a result able add. Will return false if the key is already added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Will try to get the value with this key, or if it does not exist, add the newly provided value.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.Add(`0,`1)">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.Remove(`0)">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="P:fx.Collections.HotSwapDictionary`2.Item(`0)">
            <summary>
            Set is *slow*, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.Clear">
            <summary>
            Slow, performs a *hot swap*.
            </summary>
        </member>
        <member name="M:fx.Collections.HotSwapDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            *Not implemented.
            </summary>
        </member>
        <member name="P:fx.Collections.IAdvancedDisposable.WasDisposed">
            <summary>
            Gets a value indicating if the object was already disposed.
            </summary>
        </member>
        <member name="T:fx.Collections.IDisposableDictionary">
            <summary>
            Interface that must be implemented by IPfzDictionaries that also support dispose. This is used, for example, by
            the WeakDictionaries and also by the "Locked" dictionaries, which release the lock over the main dictionary when
            disposed.
            </summary>
        </member>
        <member name="T:fx.Collections.IDisposableDictionary`2">
            <summary>
            Interface that must be implemented by IPfzDictionaries that also support dispose. This is used, for example, by
            the WeakDictionaries and also by the "Locked" dictionaries, which release the lock over the main dictionary when
            disposed.
            </summary>
        </member>
        <member name="T:fx.Collections.IPfzDictionary">
            <summary>
            Alternative dictionary interface. This one does not use ICollection for keys and values, using simple
            IEnumerables and also has many multi-action methods, like GetOrCreateValue, AddMany, RemoveMany and others.
            Also, it defines TrimExcess and SetCapacity, which are available in lists and hashsets but not in dictionaries.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.TypeOfKeys">
            <summary>
            Gets the type of the keys used by this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.TypeOfValues">
            <summary>
            Gets the type of the values used by this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Item(System.Object)">
            <summary>
            Gets or sets the value by its key. When getting, if the value does not exist, throws an ArgumentException.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Capacity">
            <summary>
            Gets the Capacity (the number of items that this dictionary supports) before trying to grow.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Comparer">
            <summary>
            Gets the equality comparer used by this dictionary to do key comparisons
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Count">
            <summary>
            Gets the actual number of items in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Keys">
            <summary>
            Returns an object capable of enumerating all the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary.Values">
            <summary>
            Returns an object capable of enumerating all the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TrimExcess">
            <summary>
            Tries to reduce the Capacity of this dictionary to a value near the Count. Can return false if it is not possible
            (by hashing rules) or necessary (because it has the good size). Can also throw an exception if there is no memory
            but it is expected that all items remain intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.SetCapacity(System.Int32)">
            <summary>
            Tries to change the capacity of this dictionary to a value given by the user. Can return false if it is not possible
            by hashing rules or size. Can also throw an exception if there is no memory but it is expected that all items remain
            intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.Clear">
            <summary>
            Clears this dictionary. This does not mean it has reduced its capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.ContainsKey(System.Object)">
            <summary>
            Verifies if a key is present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryGetValue(System.Object,System.Object@)">
            <summary>
            Tries to get a value for a given key. The return can be either true, meaning a value was found and put in the out
            value variable, or false meaning that there are no items with that key (and so the value contains the
            default(TValue)).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryGetValueOrAdd(System.Object,System.Object,System.Object@)">
            <summary>
            Tries to get a value for a given key in this dictionary. If one is not found, adds the given value. Returns true if
            a value was found for the key, false if the value was created. If the value was added, the oldValue should always be
            default(TValue). If you simple want to get a value, be it old or new, use GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryGetValueAndRemove(System.Object,System.Object@)">
            <summary>
            Tries to get a value and also remove it. If the value existed, the out value will contain it. If not, the
            default(TValue) will be returned. In either case, true means a value was there (even null) while false means an item
            with that key was not there.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryGetValueAndAddOrReplace(System.Object,System.Object,System.Object@)">
            <summary>
            In a single operation, tries to get the value for a given key. If the key does not exist, the pair (key and value)
            is added. If it already exists, the value is replaced. In any case, the result is true if an oldValue existed, false
            otherwise.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.GetValueOrDefault(System.Object)">
            <summary>
            Tries to get the value for a given key but, if it is not there, the default TValue is returned. This is very useful
            in cases where the default already means there is no value (like null results).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.GetOrCreateValue(System.Object)">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item (using the
            default TValue constructor) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.GetOrCreateValue(System.Object,System.Delegate)">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item (using the
            createValue delegate) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.GetOrAdd(System.Object,System.Object)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on the
            dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.Remove(System.Object)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.GetValueAndRemove(System.Object)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryAdd(System.Object,System.Object)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.Add(System.Object,System.Object)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.ForEach(System.Delegate)">
            <summary>
            Executes the same action for all pairs in this dictionary. This is usually faster than doing a normal foreach over
            the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.AddMany(System.Collections.IEnumerable)">
            <summary>
            Adds many items at once. This one is generally faster than adding  each item individually because the final size can
            be pre-calculated. For thread-safe implementations, this can also reduce the number of locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.AddOrReplaceMany(System.Collections.IEnumerable)">
            <summary>
            Adds or replaces many items at once. This one is generally faster than  adding or replacing each item individually
            because the final size can be  pre-calculated. For thread-safe implementations, this can also reduce the number of
            locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.TryAddMany(System.Collections.IEnumerable)">
            <summary>
            Tries to add many items at once. This one is generally faster than  trying to add each item individually because the
            final size can be  pre-calculated. For thread-safe implementations, this can also reduce the number of locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.RemoveMany(System.Collections.IEnumerable)">
            <summary>
            Removes many items at once using a collection of keys. This is usually faster than doing many removes on thread safe
            implementations as a single  lock can be obtained.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.RemoveMany(System.Delegate)">
            <summary>
            Removes many items at once using a delegate to know if the item shoud be deleted. This is fast when a good number of
            items (50% or more) is going to be removed simple because the number of searches is reduced. But it is also useful
            on multi-threaded situations where a single lock can be taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.ToArray">
            <summary>
            Copies all the pairs in this dictionary to an array. This is useful if you plan to iterate many times as this copy
            will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is still faster
            to do it over the dictionary directly.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.CopyKeys">
            <summary>
            Copies all the keys in this dictionary to an array. This is useful if you plan to iterate many times as this copy
            will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is still faster
            to do it over the Keys directly.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary.CopyValues">
            <summary>
            Copies all the values in this dictionary to an array. This is useful if you plan to iterate many times as this copy
            will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is still faster
            to do it over the Values directly.
            </summary>
        </member>
        <member name="T:fx.Collections.IPfzDictionary`2">
            <summary>
            Alternative dictionary interface. This one does not use ICollection for keys and values, using simple
            IEnumerables and also has many multi-action methods, like GetOrCreateValue, AddMany, RemoveMany and others.
            Also, it defines TrimExcess and SetCapacity, which are available in lists and hashsets but not in dictionaries.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary`2.Item(`0)">
            <summary>
            Gets or sets (replaces) the value by its key. When getting, if the value does not exist, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary`2.Comparer">
            <summary>
            Gets the equality comparer used by this dictionary to do key comparisons
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary`2.Keys">
            <summary>
            Returns an object capable of enumerating all the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.IPfzDictionary`2.Values">
            <summary>
            Returns an object capable of enumerating all the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.ContainsKey(`0)">
            <summary>
            Verifies if a key is present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value for a given key. The return can be either true, meaning a value was found and put in the out
            value variable, or false meaning that there are no items with that key (and so the value contains the
            default(TValue)).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.GetValueOrDefault(`0)">
            <summary>
            Tries to get the value for a given key but, if it is not there, the default TValue is returned. This is very useful
            in cases where the default already means there is no value (like null results).
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item (using the
            default TValue constructor) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item (using the
            createValue delegate) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on the
            dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryGetValueOrAdd(`0,`1,`1@)">
            <summary>
            Tries to get a value for a given key in this dictionary. If one is not found, adds the given value. Returns true if
            a value was found for the key, false if the value was created. If the value was added, the oldValue should always be
            default(TValue). If you simple want to get a value, be it old or new, use GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.Remove(`0)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryGetValueAndRemove(`0,`1@)">
            <summary>
            Tries to get a value and also remove it. If the value existed, the out value will contain it. If not, the
            default(TValue) will be returned. In either case, true means a value was there (even null) while false means an item
            with that key was not there.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.GetValueAndRemove(`0)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryGetValueAndAddOrReplace(`0,`1,`1@)">
            <summary>
            In a single operation, tries to get the value for a given key. If the key does not exist, the pair (key and value)
            is added. If it already exists, the value is replaced. In any case, the result is true if an oldValue existed, false
            otherwise.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.ForEach(fx.Collections.ForEachDictionaryDelegate{`0,`1})">
            <summary>
            Executes the same action for all pairs in this dictionary. This is usually faster than doing a normal foreach over
            the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds many items at once. This one is generally faster than adding  each item individually because the final size can
            be pre-calculated. For thread-safe implementations, this can also reduce the number of locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.AddOrReplaceMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds or replaces many items at once. This one is generally faster than  adding or replacing each item individually
            because the final size can be  pre-calculated. For thread-safe implementations, this can also reduce the number of
            locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.TryAddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Tries to add many items at once. This one is generally faster than  trying to add each item individually because the
            final size can be  pre-calculated. For thread-safe implementations, this can also reduce the number of locks taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes many items at once using a collection of keys. This is usually faster on thread safe implementations as a
            single lock can be obtained.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.RemoveMany(fx.Collections.RemoveManyDictionaryDelegate{`0,`1})">
            <summary>
            Removes many items at once using a delegate to knwo if the item shoud be deleted. This is fast when a good number of
            items (50% or more) is going to be removed simple because the number of searches is reduced. But it is also useful
            on multi-threaded situations where a single lock can be taken.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.ToArray">
            <summary>
            Copies all the pairs in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the dictionary directly.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.CopyKeys">
            <summary>
            Copies all the keys in this dictionary to an array. This is useful if you plan to iterate many times as this
            copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is
            still faster to do it over the Keys directly.
            </summary>
        </member>
        <member name="M:fx.Collections.IPfzDictionary`2.CopyValues">
            <summary>
            Copies all the values in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the Values directly.
            </summary>
        </member>
        <member name="T:fx.Collections.IThreadSafeAndDisposableDictionary">
            <summary>
            Interface that must be implemented by dictionaries that are both thread safe and disposable.
            </summary>
        </member>
        <member name="T:fx.Collections.IThreadSafeAndDisposableDictionary`2">
            <summary>
            Interface that must be implemented by generic dictionaries that are both thread safe and disposable.
            </summary>
        </member>
        <member name="T:fx.Collections.IThreadSafeDictionary">
            <summary>
            Interface that must be implemented by thread-safe PfzDictionary implementations.
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary.Lock">
            <summary>
            Locks this dictionary (so no other thread can write to this dictionary and, depending on the implementation, no
            other thread can read) and returns an object that you can use to do many operations that will not try to reacquire
            any lock (so, for many operations, this is faster). At the end of your actions, you should dispose the returned
            dictionary to release the lock. If the thread that does do lock does any call to the normal methods while the lock
            is held, it can dead-lock (that's, again, implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary.GetOrCreateDiscardableValue(System.Object)">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the other value, which  was already registered is returned and the generated value is
            simple lost (and,  in case of reference types, will be garbage collected sometime).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary.GetOrCreateDiscardableValue(System.Object,System.Delegate)">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the other value, which  was already registered is returned and the generated value is
            simple lost (and,  in case of reference types, will be garbage collected sometime).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary.GetOrCreateDiscardableValue(System.Object,System.Delegate,System.Delegate)">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the discardUnusedValue delegate is called (so you can dispose, close or do anything
            necessary to discard the value generated and which will not be used) and finally the other result will be returned.
            </summary>
        </member>
        <member name="T:fx.Collections.IThreadSafeDictionary`2">
            <summary>
            Interface that must be implemented by thread-safe PfzDictionary implementations.
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary`2.Lock">
            <summary>
            Locks this dictionary (so no other thread can write to this dictionary and, depending on the implementation,
            no other thread can read) and returns an object that you can use to do many operations that will not try to
            reacquire any lock (so, for many operations, this is faster). At the end of your actions, you should dispose
            the returned dictionary to release the lock. If the thread that does do lock does any call to the normal
            methods while the lock is held, it can dead-lock (that's, again, implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0)">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the other value, which  was already registered is returned and the generated value is
            simple lost (and,  in case of reference types, will be garbage collected sometime).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1})">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the other value, which  was already registered is returned and the generated value is
            simple lost (and,  in case of reference types, will be garbage collected sometime).
            </summary>
        </member>
        <member name="M:fx.Collections.IThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1},fx.Collections.DiscardUnusedValueDelegate{`0,`1})">
            <summary>
            Tries to get a value for the given key. If the value does not exist, a new one is generated, without holding locks
            and when it finishes the creation, gets the lock and a new check is done. If another  thread put a value while this
            thread generated a value, the discardUnusedValue delegate is called (so you can dispose, close or do anything
            necessary to discard the value generated and which will not be used) and finally the other result will be returned.
            </summary>
        </member>
        <member name="T:fx.Collections.ListEx`1">
            <summary>
            Some current components have this old name binary stored in their persistence info. To be removed shortly.
            </summary>
            <typeparam name="TClass"></typeparam>
        </member>
        <member name="T:fx.Collections.ListUnique`1">
            <summary>
            Extends the bahaviour of the PooledList class to provide single entry mode, etc. No duplication of item is allowed in
            the class by default.
            </summary>
            <typeparam name="TClass"></typeparam>
        </member>
        <member name="P:fx.Collections.ListUnique`1.SingleEntryMode">
            <summary>
            An item is allowed to enter only once.
            </summary>
        </member>
        <member name="M:fx.Collections.ListUnique`1.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.ListUnique`1.UpdateItem(`0,System.Boolean)">
            <summary>
            Add/Update item entry.
            </summary>
        </member>
        <member name="M:fx.Collections.ListUnique`1.Add(`0)">
            <summary>
            Add operation override.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:fx.Collections.LockedThreadSafeDictionary`2">
            <summary>
            PooledDictionary returned by the ThreadSafeDictionary&lt;TKey, TValue&gt;.Lock() method. It is recommended that you
            use this in a using clause so, when you finish, you dispose this dictionary and also release the lock held by
            it. All methods present in this dictionary simple avoid new locks, as the dictionary is already locked.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.Dispose">
            <summary>
            Releases the lock held over the main dictionary and also makes this object useless.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.WasDisposed">
            <summary>
            Gets a value indicating if this locked-dictionary was already disposed.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Item(`0)">
            <summary>
            Gets or sets a value by its key.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Capacity">
            <summary>
            Gets the actual capacity of this dictionary. This is not a real limit, but the number of buckets that exist.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Count">
            <summary>
            Gets the number of items in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Comparer">
            <summary>
            Gets the comparer used by this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Keys">
            <summary>
            Enumerates the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeDictionary`2.Values">
            <summary>
            Enumerates the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TrimExcess">
            <summary>
            Reduces the capacity of this dictionary to meet its Count property.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.SetCapacity(System.Int32)">
            <summary>
            Sets the capacity (number of buckets) of this dictionary to a given value.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.Clear">
            <summary>
            Removes all items from this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.ContainsKey(`0)">
            <summary>
            Verifies if an item with the given key exists in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value by its key. Returns true if the value is found and puts it into the out variable.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetValueOrDefault(`0)">
            <summary>
            Gets the value for a given key or, if one does not exists, returns the default(TValue).
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Gets a value for a given key or creates a new one using the default constructor of the TValue type.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Gets a value for a given key or creates a new one using the given createValue delegate.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryGetValueOrAdd(`0,`1,`1@)">
            <summary>
            Tries to get a value for a given key. If a value does not exist, adds the given one. If a value already
            existed, the return is true and the gotValue will have the existing value. If a value didn't exist, the
            return is false (as the TryGetValue failed), the given value will be added but the gotValue will have the
            default(TValue). If you simple was to get a value, be it because you added it or because it already existed,
            without knowing if it was you that added it, call GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryGetValueAndRemove(`0,`1@)">
            <summary>
            Tries to get a value by its key and also removes it. The return is true if a value existed, so the out value
            will have it and it will be already gone from the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryGetValueAndAddOrReplace(`0,`1,`1@)">
            <summary>
            Tries to get a value for a key and returns it into the oldValue parameter. Independent if one exists or not,
            the value is added or replaced by the given value.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on
            the dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.Remove(`0)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetValueAndRemove(`0)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is
            thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.ForEach(fx.Collections.ForEachDictionaryDelegate{`0,`1})">
            <summary>
            Executes the same action for all the pairs in this dictionary. This is usually faster than iterating the
            dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds many pairs at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.AddOrReplaceMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds or replaces many values at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.TryAddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Tries to add many items at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove many items at once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.RemoveMany(fx.Collections.RemoveManyDictionaryDelegate{`0,`1})">
            <summary>
            Remove many pairs at once. Each pair will call the checkDelegate to know if it should be removed or not.
            This is much faster than iterating the entire dictionary and then removing the unnecessary items.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.ToArray">
            <summary>
            Copies all the pairs of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.CopyKeys">
            <summary>
            Copies all the keys of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.CopyValues">
            <summary>
            Copies all the values of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeDictionary`2.GetEnumerator">
            <summary>
            Get an enumerator of all pairs presents in this dictionary.
            </summary>
        </member>
        <member name="T:fx.Collections.LockedThreadSafeIndexedDictionary`2">
            <summary>
            PooledDictionary returned by the ThreadSafeIndexedDictionary&lt;TKey, TValue&gt;.Lock() method. It is recommended that
            you use this in a using clause so, when you finish, you dispose this dictionary and also release the lock held
            by it. All methods present in this dictionary simple avoid new locks, as the dictionary is already locked.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.Dispose">
            <summary>
            Releases the lock held over the main dictionary and also makes this object useless.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.WasDisposed">
            <summary>
            Gets a value indicating if this locked-dictionary was already disposed.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Item(`0)">
            <summary>
            Gets or sets a value by its key.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Capacity">
            <summary>
            Gets the actual capacity of this dictionary. This is not a real limit, but the number of buckets that exist.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Count">
            <summary>
            Gets the number of items in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Comparer">
            <summary>
            Gets the comparer used by this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Keys">
            <summary>
            Enumerates the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.LockedThreadSafeIndexedDictionary`2.Values">
            <summary>
            Enumerates the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TrimExcess">
            <summary>
            Reduces the capacity of this dictionary to meet its Count property.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.SetCapacity(System.Int32)">
            <summary>
            Sets the capacity (number of buckets) of this dictionary to a given value.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.Clear">
            <summary>
            Removes all items from this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.ContainsKey(`0)">
            <summary>
            Verifies if an item with the given key exists in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value by its key. Returns true if the value is found and puts it into the out variable.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetValueOrDefault(`0)">
            <summary>
            Gets the value for a given key or, if one does not exists, returns the default(TValue).
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Gets a value for a given key or creates a new one using the default constructor of the TValue type.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Gets a value for a given key or creates a new one using the given createValue delegate.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryGetValueOrAdd(`0,`1,`1@)">
            <summary>
            Tries to get a value for a given key. If a value does not exist, adds the given one. If a value already
            existed, the return is true and the gotValue will have the existing value. If a value didn't exist, the
            return is false (as the TryGetValue failed), the given value will be added but the gotValue will have the
            default(TValue). If you simple was to get a value, be it because you added it or because it already existed,
            without knowing if it was you that added it, call GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryGetValueAndRemove(`0,`1@)">
            <summary>
            Tries to get a value by its key and also removes it. The return is true if a value existed, so the out value
            will have it and it will be already gone from the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryGetValueAndAddOrReplace(`0,`1,`1@)">
            <summary>
            Tries to get a value for a key and returns it into the oldValue parameter. Independent if one exists or not,
            the value is added or replaced by the given value.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on
            the dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.Remove(`0)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetValueAndRemove(`0)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is
            thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.ForEach(fx.Collections.ForEachDictionaryDelegate{`0,`1})">
            <summary>
            Executes the same action for all the pairs in this dictionary. This is usually faster than iterating the
            dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds many pairs at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.AddOrReplaceMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds or replaces many values at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.TryAddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Tries to add many items at once. If the capacity needs to grow, it is done only once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove many items at once.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.RemoveMany(fx.Collections.RemoveManyDictionaryDelegate{`0,`1})">
            <summary>
            Remove many pairs at once. Each pair will call the checkDelegate to know if it should be removed or not.
            This is much faster than iterating the entire dictionary and then removing the unnecessary items.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.ToArray">
            <summary>
            Copies all the pairs of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.CopyKeys">
            <summary>
            Copies all the keys of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.CopyValues">
            <summary>
            Copies all the values of this dictionary to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.LockedThreadSafeIndexedDictionary`2.GetEnumerator">
            <summary>
            Get an enumerator of all pairs presents in this dictionary.
            </summary>
        </member>
        <member name="T:fx.Collections.RemoveManyDictionaryDelegate`2">
            <summary>
            Delegate used by the dictionaries RemoveMany method to check if a pair should be removed. Returning true the
            pair is removed while returning false they remain there.
            </summary>
        </member>
        <member name="T:fx.Collections.SortedListEx`2">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.SortedListEx`2.RemoveFirstValue(`1)">
             <summary>
            
             </summary>
        </member>
        <member name="M:fx.Collections.DictionaryHelper.AdaptSize(System.Int32)">
            <summary>
            This method is used by the dictionary implementations to adapt a given size to a prime number (or at least
            to some number that's not easily divided).
            </summary>
        </member>
        <member name="T:fx.Collections.ThreadSafeDictionary`2">
            <summary>
            A thread safe implementation of a dictionary that allows reads to be done even when writes are being done.
            Writes are serialized, though.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.#ctor">
            <summary>
            Creates a dictionary with its default capacity and key comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary with the given capacity and the default key comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.#ctor(fx.Collections.IReaderWriterLockSlim)">
            <summary>
            Create a new thread-safe dictionary using the given readerWriterLock for synchronization.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new dictionary with the given key comparer and using the default capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.#ctor(System.Int32,fx.Collections.IReaderWriterLockSlim,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new dictionary with the given capacity and key comparer.
            </summary>
            <param name="capacity">The capacity to use.</param>
            <param name="readerWriterLock">
            The reader writer lock to use. If null, a SpinReaderWriterLockSlim on multi-processor computers or an
            OptimisticReaderWriterLock will be used on single CPU computers.
            </param>
            <param name="comparer">The comparer to use for the keys. A value of null means the default one will be used.</param>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Item(`0)">
            <summary>
            Gets or sets (replaces) the value by its key. When getting, if the value does not exist, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Comparer">
            <summary>
            Gets the equality comparer used by this dictionary to do key comparisons
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Count">
            <summary>
            Gets the actual number of items in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Capacity">
            <summary>
            Gets the Capacity (the number of items that this dictionary supports) before trying to grow.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Keys">
            <summary>
            Returns an object capable of enumerating all the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeDictionary`2.Values">
            <summary>
            Returns an object capable of enumerating all the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.ContainsKey(`0)">
            <summary>
            Verifies if a key is present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value for a given key. The return can be either true, meaning a value was found and put in
            the out value variable, or false meaning that there are no items with that key (and so the value contains
            the default(TValue)).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryGetValueAndAddOrReplace(`0,`1,`1@)">
            <summary>
            In a single operation, tries to get the value for a given key. If the key does not exist, the pair (key and
            value) is added. If it already exists, the value is replaced. In any case, the result is true if an oldValue
            existed, false otherwise.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryGetValueOrAdd(`0,`1,`1@)">
            <summary>
            Tries to get a value for a given key in this dictionary. If one is not found, adds the given value. Returns
            true if a value was found for the key, false if the value was created. If the value was added, the oldValue
            should always be default(TValue). If you simple want to get a value, be it old or new, use GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryGetValueAndRemove(`0,`1@)">
            <summary>
            Tries to get a value and also remove it. If the value existed, the out value will contain it. If not, the
            default(TValue) will be returned. In either case, true means a value was there (even null) while false means
            an item with that key was not there.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.Clear">
            <summary>
            Clears this dictionary. This does not mean it has reduced its capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetValueOrDefault(`0)">
            <summary>
            Tries to get the value for a given key but, if it is not there, the default TValue is returned. This is very
            useful in cases where the default already means there is no value (like null results).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item
            (using the default TValue constructor) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item
            (using the createValue delegate) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0)">
            <summary>
            Gets or creates a value for a given key, using the default constructor for TValue. If the value needs to be
            created it is created outside of a lock, so duplicates may be created, but one of them will never be used
            (and will be simple lost, if you need to dispose an unused value, see the overload with a discardUnusedValue
            delegate).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1})">
            <summary>
            Gets or creates a value for a given key, using the given createDelegate. If the value needs to be created it
            is created outside of a lock, so duplicates may be created, but one of them will never be used (and will be
            simple lost, if you need to dispose an unused value, see the overload with a discardUnusedValue delegate).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1},fx.Collections.DiscardUnusedValueDelegate{`0,`1})">
            <summary>
            Gets or creates a value for a given key, using the given createDelegate. If the value needs to be created it
            is created outside of a lock, so duplicates may be created, but one of them will never be used and the
            discardUnusedValue will be called to discard it proberly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on
            the dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.SetCapacity(System.Int32)">
            <summary>
            Tries to change the capacity of this dictionary to a value given by the user. Can return false if it is not
            possible by hashing rules or size. Can also throw an exception if there is no memory but it is expected that
            all items remain intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TrimExcess">
            <summary>
            Tries to reduce the Capacity of this dictionary to a value near the Count. Can return false if it is not
            possible (by hashing rules) or necessary (because it has the good size). Can also throw an exception if
            there is no memory but it is expected that all items remain intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetValueAndRemove(`0)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is
            thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.Remove(`0)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.Lock">
            <summary>
            Locks this dictionary, avoiding any other thread to change this dictionary, and returns a disposable
            dictionary instance that you should use to do all your actions, that will avoid new lock. When  you finish
            your actions you should dispose such dictionary to release  the lock. If you try to use this dictionary
            instead of the locked one while you hold the lock you will probably cause a dead-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.ForEach(fx.Collections.ForEachDictionaryDelegate{`0,`1})">
            <summary>
            Executes the same action for all items in this dictionary. This is done in a no-lock technique and avoids
            copying the  pairs in this dictionary. This is usually faster than iterating over the dictionary with a
            normal foreach clause.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.RemoveMany(fx.Collections.RemoveManyDictionaryDelegate{`0,`1})">
            <summary>
            Removes many items at once using a delegate to know if the item shoud be deleted. This is fast when a good
            number of items (50% or more) is going to be removed simple because the number of searches and the number of
            locks is reduced.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes many items at once using a collection of keys. This is usually faster than doing many remoes as a
            single lock is obtained.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds many items at once. This one is generally faster than adding  each item individually because the final
            size can be pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.AddOrReplaceMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds or replaces many items at once. This one is generally faster than  adding or replacing each item
            individually because the final size can be  pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.TryAddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Tries to add many items at once. This one is generally faster than  trying to add each item individually
            because the final size can be  pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator so you can see all the key-value pairs present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.ToArray">
            <summary>
            Copies all the pairs in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the dictionary directly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.CopyKeys">
            <summary>
            Copies all the keys in this dictionary to an array. This is useful if you plan to iterate many times as this
            copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is
            still faster to do it over the Keys directly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeDictionary`2.CopyValues">
            <summary>
            Copies all the values in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the Values directly.
            </summary>
        </member>
        <member name="T:fx.Collections.ThreadSafeIndexedDictionary`2">
            <summary>
            A thread safe implementation of a dictionary that allows reads to be done even when writes are being done.
            Writes are serialized, though.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.#ctor">
            <summary>
            Creates a dictionary with its default capacity and key comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary with the given capacity and the default key comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.#ctor(fx.Collections.IReaderWriterLockSlim)">
            <summary>
            Create a new thread-safe dictionary using the given readerWriterLock for synchronization.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new dictionary with the given key comparer and using the default capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.#ctor(System.Int32,fx.Collections.IReaderWriterLockSlim,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new dictionary with the given capacity and key comparer.
            </summary>
            <param name="capacity">The capacity to use.</param>
            <param name="readerWriterLock">
            The reader writer lock to use. If null, a SpinReaderWriterLockSlim on multi-processor computers or an
            OptimisticReaderWriterLock will be used on single CPU computers.
            </param>
            <param name="comparer">The comparer to use for the keys. A value of null means the default one will be used.</param>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Item(`0)">
            <summary>
            Gets or sets (replaces) the value by its key. When getting, if the value does not exist, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Comparer">
            <summary>
            Gets the equality comparer used by this dictionary to do key comparisons
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Count">
            <summary>
            Gets the actual number of items in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Capacity">
            <summary>
            Gets the Capacity (the number of items that this dictionary supports) before trying to grow.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Keys">
            <summary>
            Returns an object capable of enumerating all the keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.ThreadSafeIndexedDictionary`2.Values">
            <summary>
            Returns an object capable of enumerating all the values in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.ContainsKey(`0)">
            <summary>
            Verifies if a key is present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value for a given key. The return can be either true, meaning a value was found and put in
            the out value variable, or false meaning that there are no items with that key (and so the value contains
            the default(TValue)).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryGetValueAndAddOrReplace(`0,`1,`1@)">
            <summary>
            In a single operation, tries to get the value for a given key. If the key does not exist, the pair (key and
            value) is added. If it already exists, the value is replaced. In any case, the result is true if an oldValue
            existed, false otherwise.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryGetValueOrAdd(`0,`1,`1@)">
            <summary>
            Tries to get a value for a given key in this dictionary. If one is not found, adds the given value. Returns
            true if a value was found for the key, false if the value was created. If the value was added, the oldValue
            should always be default(TValue). If you simple want to get a value, be it old or new, use GetOrAdd.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryGetValueAndRemove(`0,`1@)">
            <summary>
            Tries to get a value and also remove it. If the value existed, the out value will contain it. If not, the
            default(TValue) will be returned. In either case, true means a value was there (even null) while false means
            an item with that key was not there.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.Clear">
            <summary>
            Clears this dictionary. This does not mean it has reduced its capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetValueOrDefault(`0)">
            <summary>
            Tries to get the value for a given key but, if it is not there, the default TValue is returned. This is very
            useful in cases where the default already means there is no value (like null results).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item
            (using the default TValue constructor) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrCreateValue(`0,System.Func{`0,`1})">
            <summary>
            Exceptions aside, this method always returns a value, be it because a new value was generated for an item
            (using the createValue delegate) or because the item already existed.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrCreateDiscardableValue(`0)">
            <summary>
            Gets or creates a value for a given key, using the default constructor for TValue. If the value needs to be
            created it is created outside of a lock, so duplicates may be created, but one of them will never be used
            (and will be simple lost, if you need to dispose an unused value, see the overload with a discardUnusedValue
            delegate).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1})">
            <summary>
            Gets or creates a value for a given key, using the given createDelegate. If the value needs to be created it
            is created outside of a lock, so duplicates may be created, but one of them will never be used (and will be
            simple lost, if you need to dispose an unused value, see the overload with a discardUnusedValue delegate).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrCreateDiscardableValue(`0,System.Func{`0,`1},fx.Collections.DiscardUnusedValueDelegate{`0,`1})">
            <summary>
            Gets or creates a value for a given key, using the given createDelegate. If the value needs to be created it
            is created outside of a lock, so duplicates may be created, but one of them will never be used and the
            discardUnusedValue will be called to discard it proberly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.Add(`0,`1)">
            <summary>
            Adds an item with the given key and value. If another item with the same key exists, throws an
            ArgumentException.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets an item or adds the given value to the dictionary. The result should be the item that is actually on
            the dictionary, independent of the reason.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add an item. If an item with the same key exists, it returns false.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.SetCapacity(System.Int32)">
            <summary>
            Tries to change the capacity of this dictionary to a value given by the user. Can return false if it is not
            possible by hashing rules or size. Can also throw an exception if there is no memory but it is expected that
            all items remain intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TrimExcess">
            <summary>
            Tries to reduce the Capacity of this dictionary to a value near the Count. Can return false if it is not
            possible (by hashing rules) or necessary (because it has the good size). Can also throw an exception if
            there is no memory but it is expected that all items remain intact. (implementation specific).
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetValueAndRemove(`0)">
            <summary>
            Gets the actual value for an item and then removes it. If the item does not exist, an ArgumentException is
            thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.Remove(`0)">
            <summary>
            Tries to removes a value by its key and returns if a value existed and was removed or not.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.Lock">
            <summary>
            Locks this dictionary, avoiding any other thread to change this dictionary, and returns a disposable
            dictionary instance that you should use to do all your actions, that will avoid new lock. When  you finish
            your actions you should dispose such dictionary to release  the lock. If you try to use this dictionary
            instead of the locked one while you hold the lock you will probably cause a dead-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.ForEach(fx.Collections.ForEachDictionaryDelegate{`0,`1})">
            <summary>
            Executes the same action for all items in this dictionary. This is done in a no-lock technique and avoids
            copying the  pairs in this dictionary. This is usually faster than iterating over the dictionary with a
            normal foreach clause.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.RemoveMany(fx.Collections.RemoveManyDictionaryDelegate{`0,`1})">
            <summary>
            Removes many items at once using a delegate to know if the item shoud be deleted. This is fast when a good
            number of items (50% or more) is going to be removed simple because the number of searches and the number of
            locks is reduced.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes many items at once using a collection of keys. This is usually faster than doing many remoes as a
            single lock is obtained.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds many items at once. This one is generally faster than adding  each item individually because the final
            size can be pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.AddOrReplaceMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds or replaces many items at once. This one is generally faster than  adding or replacing each item
            individually because the final size can be  pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.TryAddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Tries to add many items at once. This one is generally faster than  trying to add each item individually
            because the final size can be  pre-calculated.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.GetEnumerator">
            <summary>
            Gets an enumerator so you can see all the key-value pairs present in this dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.ToArray">
            <summary>
            Copies all the pairs in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the dictionary directly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.CopyKeys">
            <summary>
            Copies all the keys in this dictionary to an array. This is useful if you plan to iterate many times as this
            copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once, it is
            still faster to do it over the Keys directly.
            </summary>
        </member>
        <member name="M:fx.Collections.ThreadSafeIndexedDictionary`2.CopyValues">
            <summary>
            Copies all the values in this dictionary to an array. This is useful if you plan to iterate many times as
            this copy will not change and because iterating in arrays is faster. But, if you plan to iterate only once,
            it is still faster to do it over the Values directly.
            </summary>
        </member>
        <member name="T:fx.Collections.ValueConstructorDelegate`2">
            <summary>
            Class that holds a delegate to construct dictionary values (a Func&lt;TKey, TValue&gt;) using the default TValue
            constructor.
            </summary>
        </member>
        <member name="M:fx.Collections.ValueConstructorDelegate`2.#cctor">
            <summary>
            Initializes the delegate.
            </summary>
        </member>
        <member name="M:fx.Collections.ValueConstructorDelegate`2.TryGetDefault">
            <summary>
            Tries to get a default constructor delegate or returns null.
            </summary>
        </member>
        <member name="M:fx.Collections.ValueConstructorDelegate`2.GetDefault">
            <summary>
            Gets the constructor delegate or throws an InvalidOperationException.
            </summary>
        </member>
        <member name="T:fx.Collections.DictionarySlim`2">
             <summary>
             A lightweight Dictionary with three principal differences compared to <see cref="T:System.Collections.Generic.Dictionary`2"/>
            
             1) It is possible to do "get or add" in a single lookup using <see cref="M:fx.Collections.DictionarySlim`2.GetOrAddValueRef(`0)"/>. For
             values that are value types, this also saves a copy of the value.
             2) It assumes it is cheap to equate values.
             3) It assumes the keys implement <see cref="T:System.IEquatable`1"/> or else Equals() and they are cheap and sufficient.
             </summary>
             <remarks>
             1) This avoids having to do separate lookups (<see cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>
             followed by <see cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>.
             There is not currently an API exposed to get a value by ref without adding if the key is not present.
             2) This means it can save space by not storing hash codes.
             3) This means it can avoid storing a comparer, and avoid the likely virtual call to a comparer.
             </remarks>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.#ctor">
            <summary>
            Construct with default capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.#ctor(System.Int32)">
            <summary>
            Construct with at least the specified capacity for
            entries before resizing must occur.
            </summary>
            <param name="capacity">Requested minimum capacity</param>
        </member>
        <member name="P:fx.Collections.DictionarySlim`2.Count">
            <summary>
            Count of entries in the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.Clear">
            <summary>
            Clears the dictionary. Note that this invalidates any active enumerators.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.ContainsKey(`0)">
            <summary>
            Looks for the specified key in the dictionary.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value if present for the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <param name="value">Value found, otherwise default(TValue)</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.Remove(`0)">
            <summary>
            Removes the entry if present with the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, false if it is not</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.GetOrAddValueRef(`0)">
            <summary>
            Gets the value for the specified key, or, if the key is not present,
            adds an entry and returns the value by ref. This makes it possible to
            add or update a value in a single look up operation.
            </summary>
            <param name="key">Key to look for</param>
            <returns>Reference to the new or existing value</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="T:fx.Collections.DictionarySlim`2.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.Enumerator.MoveNext">
            <summary>
            Move to next
            </summary>
        </member>
        <member name="P:fx.Collections.DictionarySlim`2.Enumerator.Current">
            <summary>
            Get current value
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlim`2.Enumerator.Dispose">
            <summary>
            Dispose the enumerator
            </summary>
        </member>
        <member name="T:fx.Collections.DictionarySlimP`2">
             <summary>
             A lightweight Dictionary with three principal differences compared to <see cref="T:System.Collections.Generic.Dictionary`2"/>
            
             1) It is possible to do "get or add" in a single lookup using <see cref="M:fx.Collections.DictionarySlimP`2.GetOrAddValueRef(`0)"/>. For
             values that are value types, this also saves a copy of the value.
             2) It assumes it is cheap to equate values.
             3) It assumes the keys implement <see cref="T:System.IEquatable`1"/> or else Equals() and they are cheap and sufficient.
             </summary>
             <remarks>
             1) This avoids having to do separate lookups (<see cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>
             followed by <see cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>.
             There is not currently an API exposed to get a value by ref without adding if the key is not present.
             2) This means it can save space by not storing hash codes.
             3) This means it can avoid storing a comparer, and avoid the likely virtual call to a comparer.
             </remarks>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.#ctor">
            <summary>
            Construct with default capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.#ctor(System.Int32)">
            <summary>
            Construct with at least the specified capacity for
            entries before resizing must occur.
            </summary>
            <param name="capacity">Requested minimum capacity</param>
        </member>
        <member name="P:fx.Collections.DictionarySlimP`2.Count">
            <summary>
            Count of entries in the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.Clear">
            <summary>
            Clears the dictionary. Note that this invalidates any active enumerators.
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.ContainsKey(`0)">
            <summary>
            Looks for the specified key in the dictionary.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value if present for the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <param name="value">Value found, otherwise default(TValue)</param>
            <returns>true if the key is present, otherwise false</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.Remove(`0)">
            <summary>
            Removes the entry if present with the specified key.
            </summary>
            <param name="key">Key to look for</param>
            <returns>true if the key is present, false if it is not</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.GetOrAddValueRef(`0)">
            <summary>
            Gets the value for the specified key, or, if the key is not present,
            adds an entry and returns the value by ref. This makes it possible to
            add or update a value in a single look up operation.
            </summary>
            <param name="key">Key to look for</param>
            <returns>Reference to the new or existing value</returns>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator over the dictionary
            </summary>
        </member>
        <member name="T:fx.Collections.DictionarySlimP`2.Enumerator">
            <summary>
            Enumerator
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.Enumerator.MoveNext">
            <summary>
            Move to next
            </summary>
        </member>
        <member name="P:fx.Collections.DictionarySlimP`2.Enumerator.Current">
            <summary>
            Get current value
            </summary>
        </member>
        <member name="M:fx.Collections.DictionarySlimP`2.Enumerator.Dispose">
            <summary>
            Dispose the enumerator
            </summary>
        </member>
        <member name="T:fx.Collections.IReadOnlyPooledList`1">
            <summary>
            Represents a read-only collection of pooled elements that can be accessed by index
            </summary>
            <typeparam name="T">The type of elements in the read-only pooled list.</typeparam>
        </member>
        <member name="P:fx.Collections.IReadOnlyPooledList`1.Span">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> for the items currently in the collection.
            </summary>
        </member>
        <member name="T:fx.Collections.NonRandomizedStringEqualityComparer">
            <summary>
            NonRandomizedStringEqualityComparer is the comparer used by default with the PooledDictionary.
            We use NonRandomizedStringEqualityComparer as default comparer as it doesnt use the randomized string hashing which 
            keeps the performance not affected till we hit collision threshold and then we switch to the comparer which is using 
            randomized string hashing.
            </summary>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2">
            <summary>
            Represents an ordered collection of keys and values with the same performance as <see cref="T:System.Collections.Generic.Dictionary`2"/> with O(1) lookups and adds but with O(n) inserts and removes.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
            <returns>The number of key/value pairs contained in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> that is used to determine equality of keys for the dictionary.
            </summary>
            <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> generic interface implementation that is used to determine equality of keys for the current <see cref="T:fx.Collections.OrderedDictionary`2" /> and to provide hash values for the keys.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Keys">
            <summary>
            Gets a collection containing the keys in the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
            <returns>An <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" /> containing the keys in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Values">
            <summary>
            Gets a collection containing the values in the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
            <returns>An <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" /> containing the values in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key as an O(1) operation.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value associated with the specified key. If the specified key is not found, a get operation throws a <see cref="T:System.Collections.Generic.KeyNotFoundException" />, and a set operation creates a new element with the specified key.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key" /> does not exist in the collection.</exception>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index as an O(1) operation.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The value at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that is empty, has the default initial capacity, and uses the default equality comparer for the key type.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that is empty, has the specified initial capacity, and uses the default equality comparer for the key type.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:fx.Collections.OrderedDictionary`2" /> can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than 0.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:fx.Collections.OrderedDictionary`2" /> can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than 0.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that contains elements copied from the specified <see cref="!:IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;" /> and uses the default equality comparer for the key type.
            </summary>
            <param name="collection">The <see cref="!:IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;" /> whose elements are copied to the new <see cref="T:fx.Collections.OrderedDictionary`2" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection" /> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.OrderedDictionary`2" /> class that contains elements copied from the specified <see cref="!:IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;" /> and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
            <param name="collection">The <see cref="!:IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;" /> whose elements are copied to the new <see cref="T:fx.Collections.OrderedDictionary`2" />.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> for the type of the key.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection" /> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified key and value to the dictionary as an O(1) operation.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:fx.Collections.OrderedDictionary`2" /> contains the specified key as an O(1) operation.
            </summary>
            <param name="key">The key to locate in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</param>
            <returns>true if the <see cref="T:fx.Collections.OrderedDictionary`2" /> contains an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Resizes the internal data structure if necessary to ensure no additional resizing to support the specified capacity.
            </summary>
            <param name="capacity">The number of elements that the <see cref="T:fx.Collections.OrderedDictionary`2" /> must be able to contain.</param>
            <returns>The capacity of the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than 0.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
            <returns>An <see cref="T:fx.Collections.OrderedDictionary`2.Enumerator" /> structure for the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the <see cref="T:fx.Collections.OrderedDictionary`2" /> if the key does not already exist as an O(1) operation.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value to be added, if the key does not already exist.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.GetOrAdd(`0,System.Func{`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:fx.Collections.OrderedDictionary`2" /> by using the specified function, if the key does not already exist as an O(1) operation.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key.</param>
            <returns>The value for the key. This will be either the existing value for the key if the key is already in the dictionary, or the new value for the key as returned by valueFactory if the key was not in the dictionary.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.-or-<paramref name="valueFactory"/> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.IndexOf(`0)">
            <summary>
            Returns the zero-based index of the element with the specified key within the <see cref="T:fx.Collections.OrderedDictionary`2" /> as an O(1) operation.
            </summary>
            <param name="key">The key of the element to locate.</param>
            <returns>The zero-based index of the element with the specified key within the <see cref="T:fx.Collections.OrderedDictionary`2" />, if found; otherwise, -1.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Insert(System.Int32,`0,`1)">
            <summary>
            Inserts the specified key/value pair into the <see cref="T:fx.Collections.OrderedDictionary`2" /> at the specified index as an O(n) operation.
            </summary>
            <param name="index">The zero-based index of the key/value pair to insert.</param>
            <param name="key">The key of the element to insert.</param>
            <param name="value">The value of the element to insert.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than 0.-or-<paramref name="index" /> is greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Move(System.Int32,System.Int32)">
            <summary>
            Moves the element at the specified fromIndex to the specified toIndex while re-arranging the elements in between.
            </summary>
            <param name="fromIndex">The zero-based index of the element to move.</param>
            <param name="toIndex">The zero-based index to move the element to.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="fromIndex"/> is less than 0.
            -or-
            <paramref name="fromIndex"/> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />
            -or-
            <paramref name="toIndex"/> is less than 0.
            -or-
            <paramref name="toIndex"/> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />
            </exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.MoveRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves the specified number of elements at the specified fromIndex to the specified toIndex while re-arranging the elements in between.
            </summary>
            <param name="fromIndex">The zero-based index of the elements to move.</param>
            <param name="toIndex">The zero-based index to move the elements to.</param>
            <param name="count">The number of elements to move.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fromIndex"/> is less than 0.
            -or-
            <paramref name="fromIndex"/> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.
            -or-
            <paramref name="toIndex"/> is less than 0.
            -or-
            <paramref name="toIndex"/> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.
            -or-
            <paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fromIndex"/> + <paramref name="count"/> is greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.
            -or-
            <paramref name="toIndex"/> + <paramref name="count"/> is greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Remove(`0)">
            <summary>
            Removes the value with the specified key from the <see cref="T:fx.Collections.OrderedDictionary`2" /> as an O(n) operation.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if <paramref name="key" /> is not found in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes the value with the specified key from the <see cref="T:fx.Collections.OrderedDictionary`2" /> and returns the value as an O(n) operation.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if <paramref name="key" /> is not found in the <see cref="T:fx.Collections.OrderedDictionary`2" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.RemoveAt(System.Int32)">
            <summary>
            Removes the value at the specified index from the <see cref="T:fx.Collections.OrderedDictionary`2" /> as an O(n) operation.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.TrimExcess">
            <summary>
            Sets the capacity of an <see cref="T:fx.Collections.OrderedDictionary`2" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of an <see cref="T:fx.Collections.OrderedDictionary`2" /> object to the specified capacity, rounded up to a nearby, implementation-specific value.
            </summary>
            <param name="capacity">The number of elements that the <see cref="T:fx.Collections.OrderedDictionary`2" /> must be able to contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> is less than <see cref="P:fx.Collections.OrderedDictionary`2.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.TryAdd(`0,`1)">
            <summary>
            Tries to add the specified key and value to the dictionary as an O(1) operation.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be null for reference types.</param>
            <returns>true if the element was added to the <see cref="T:fx.Collections.OrderedDictionary`2" />; false if the <see cref="T:fx.Collections.OrderedDictionary`2" /> already contained an element with the specified key.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key as an O(1) operation.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
            <returns>true if the <see cref="T:fx.Collections.OrderedDictionary`2" /> contains an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is null.</exception>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
            <returns>The element in the <see cref="T:fx.Collections.OrderedDictionary`2" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Enumerator.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:fx.Collections.OrderedDictionary`2.Enumerator" />.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the <see cref="T:fx.Collections.OrderedDictionary`2" />.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2.KeyCollection">
            <summary>
            Represents the collection of keys in a <see cref="T:fx.Collections.OrderedDictionary`2" />. This class cannot be inherited.
            </summary>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.KeyCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.
            </summary>
            <returns>The number of elements contained in the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.KeyCollection.Item(System.Int32)">
            <summary>
            Gets the key at the specified index as an O(1) operation.
            </summary>
            <param name="index">The zero-based index of the key to get.</param>
            <returns>The key at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.KeyCollection.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.KeyCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.
            </summary>
            <returns>A <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator" /> for the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.</returns>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.
            </summary>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
            <returns>The element in the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator" />.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.KeyCollection.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the <see cref="T:fx.Collections.OrderedDictionary`2.KeyCollection" />.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2.ValueCollection">
            <summary>
            Represents the collection of values in a <see cref="T:fx.Collections.OrderedDictionary`2" />. This class cannot be inherited.
            </summary>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.ValueCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.
            </summary>
            <returns>The number of elements contained in the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.</returns>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.ValueCollection.Item(System.Int32)">
            <summary>
            Gets the value at the specified index as an O(1) operation.
            </summary>
            <param name="index">The zero-based index of the value to get.</param>
            <returns>The value at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is less than 0.-or-<paramref name="index" /> is equal to or greater than <see cref="P:fx.Collections.OrderedDictionary`2.ValueCollection.Count" />.</exception>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.ValueCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.
            </summary>
            <returns>A <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator" /> for the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.</returns>
        </member>
        <member name="T:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator">
            <summary>
            Enumerates the elements of a <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.
            </summary>
        </member>
        <member name="P:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator.Current">
            <summary>
            Gets the element at the current position of the enumerator.
            </summary>
            <returns>The element in the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" /> at the current position of the enumerator.</returns>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator" />.
            </summary>
        </member>
        <member name="M:fx.Collections.OrderedDictionary`2.ValueCollection.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the <see cref="T:fx.Collections.OrderedDictionary`2.ValueCollection" />.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="T:fx.Collections.PooledCollection`1">
            <summary>
            Provides the base class for a generic collection.
            Uses ArrayPool for the backing store.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledCollection`1"/> class that is empty.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledCollection`1"/> class as a wrapper for the specified list.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is null.</exception>
        </member>
        <member name="P:fx.Collections.PooledCollection`1.Count">
            <summary>
            Gets the number of elements actually contained in the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledCollection`1.Items">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IList`1"/> wrapper around the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Add(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a set of objects to the end of the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Clear">
            <summary>
            Removes all elements from the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:fx.Collections.PooledCollection`1"/> to a compatible one-dimensional Array, starting at the specified index of the target array.
            </summary>
            <param name="array">The destination array.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the entire <see cref="T:fx.Collections.PooledCollection`1"/> to a compatible <see cref="T:System.Span`1"/>.
            </summary>
            <param name="span"></param>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Contains(`0)">
            <summary>
            Determines whether an element is in the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.IndexOf(`0)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:fx.Collections.PooledCollection`1"/> at the specified index.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:fx.Collections.PooledCollection`1"/> at the specified index.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.RemoveItem(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:fx.Collections.PooledCollection`1"/>.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the element at the specified index.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Dispose">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledCollection`1.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2">
            <remarks>
            A <see cref="T:fx.Collections.PooledDictionary`2"/> can support multiple readers concurrently, as long as the collection is not modified. 
            Even so, enumerating through a collection is intrinsically not a thread-safe procedure. 
            In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. 
            To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization. 
            </remarks>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:fx.Collections.PooledDictionary`2"/>.
            </summary>
        </member>
        <member name="F:fx.Collections.PooledDictionary`2.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:fx.Collections.PooledDictionary`2.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:fx.Collections.PooledDictionary`2.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Int32,fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[])">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ValueTuple{`0,`1}[],fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of PooledDictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Comparer">
            <summary>
            The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used to compare keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Count">
            <summary>
            The number of items in the dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.KeyClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.ValueClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Keys">
            <summary>
            The keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Values">
            <summary>
            The values in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Item(`0)">
            <summary>
            Gets or sets an item in the dictionary by key.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key/value pair to the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddRange(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddRange(System.ValueTuple{`0,`1}[])">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.SetRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.SetRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.SetRange(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.SetRange(System.ValueTuple{`0,`1}[])">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the dictionary. If the key is already present, the <paramref name="updater"/>
            function is called, with the key and the current value as parameters. The value returned from this function
            will overwrite the current value.
            </summary>
            <param name="key"></param>
            <param name="addValue"></param>
            <param name="updater"></param>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the dictionary. If the key is not already present, the <paramref name="addValueFactory"/>
            function is called to generate the value for the key in question. 
            If the key is already present, the <paramref name="updater"/> function is called, with the key and
            the current value as parameters. The value returned from this function will overwrite the current value.
            </summary>
            <param name="key"></param>
            <param name="addValueFactory"></param>
            <param name="updater"></param>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the given key.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ContainsValue(`1)">
            <summary>
            Returns true if the dictionary contains the given value.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Allows child classes to add their own serialization data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.OnDeserialization(System.Object)">
            <summary>
            Called during deserialization.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Remove(`0)">
            <summary>
            Removes the item with the given key.
            Returns true if the key was found and the value successfully removed.
            </summary>
            <param name="key">The key</param>
            <returns>Returns true if the key was found and removed.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes the item with the given key.
            If the key was found, returns true and sets the <paramref name="value"/> parameter to the removed value.
            If the key was not found, returns false and sets the <paramref name="value"/> parameter to the default value for the type.
            </summary>
            <param name="key">The key</param>
            <param name="value">The removed value</param>
            <returns>Returns true if the key was found and removed.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value corresponding to the given key.
            If the key was found, returns true and sets the <paramref name="value"/> parameter to the corresponding value.
            If the key was not found, returns false and sets the <paramref name="value"/> to the default value for the type.
            </summary>
            <param name="key">The key</param>
            <param name="value">The returned value</param>
            <returns>True if the key was found, otherwise false.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the given key-value pair, if the key was not already present.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value to add</param>
            <returns>Returns true if the value was successfully added, false if the key was already present and the value was not added.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets the current value associated with the given key. If the key was not found,
            adds <paramref name="addValue"/> with the given key and returns it.
            </summary>
            <param name="key">The key</param>
            <param name="addValue">The value to add if the key was not found</param>
            <returns>Either the current value or the just-added value.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Gets the current value associated with the given key. If the key was not found,
            runs <paramref name="valueFactory"/> and adds the result with the given key, returning the newly-added value.
            </summary>
            <param name="key">The key</param>
            <param name="valueFactory">A function that will be used to generate a value to add if the key was not found</param>
            <returns>Either the current value or the just-added value.</returns>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            
            To allocate minimum size storage array, execute the following statements:
            
            dictionary.Clear();
            dictionary.TrimExcess();
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Dispose">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.Enumerator">
            <summary>
            Enumerates dictionary keys and values.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.Enumerator.MoveNext">
            <summary>
            Moves to the next item, returning false if there are no more items.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.Enumerator.Current">
            <summary>
            The current item.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.KeyCollection">
            <summary>
            A collection of dictionary keys.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.KeyCollection.#ctor(fx.Collections.PooledDictionary{`0,`1})">
            <summary>
            Creates an instance of a KeyCollection
            </summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.KeyCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.KeyCollection.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the dictionary keys to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.KeyCollection.CopyTo(System.Span{`0})">
            <summary>
             Copies the dictionary keys to a span.
            </summary>
            <param name="span"></param>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.KeyCollection.Count">
            <summary>
            The number of items in the collection.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.KeyCollection.Enumerator">
            <summary>
            The enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.KeyCollection.Enumerator.MoveNext">
            <summary>
            Moves to the next value, returning false if there are no more values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.KeyCollection.Enumerator.Current">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.ValueCollection">
            <summary>
            A collection of dicationary values.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ValueCollection.#ctor(fx.Collections.PooledDictionary{`0,`1})">
            <summary>
            Creates an instance of ValueCollection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ValueCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ValueCollection.CopyTo(`1[],System.Int32)">
            <summary>
            Copies the dictionary values to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ValueCollection.CopyTo(System.Span{`1})">
            <summary>
            Copies the dictionary values to the given span.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.ValueCollection.Count">
            <summary>
            The count of items.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledDictionary`2.ValueCollection.Enumerator">
            <summary>
            A dictionary enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledDictionary`2.ValueCollection.Enumerator.MoveNext">
            <summary>
            Moves to the next value, returning false if there are no more values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.PooledDictionary`2.ValueCollection.Enumerator.Current">
            <summary>
            Returns the current value.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledExtensions">
            <summary>
            Extension methods for creating pooled collections.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(``0[])">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(System.ReadOnlySpan{``0})">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(System.Span{``0})">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(System.ReadOnlyMemory{``0})">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledList``1(System.Memory{``0})">
            <summary>
            Converts the collection to a new <see cref="T:fx.Collections.PooledList`1"/> instance.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``3(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a <see cref="T:System.ReadOnlySpan`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``3(System.Span{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a <see cref="T:System.Span`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``3(System.ReadOnlyMemory{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a <see cref="T:System.ReadOnlyMemory`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``3(System.Memory{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a <see cref="T:System.Memory`1"/> according to specified 
            key selector and element selector functions, as well as a comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.ReadOnlySpan`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Span{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.Span`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.ReadOnlyMemory{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.ReadOnlyMemory`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Memory{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from an <see cref="T:System.Memory`1"/> according to specified 
            key selector and comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a sequence of key/value tuples.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a sequence of KeyValuePair values.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a sequence of key/value tuples.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.ReadOnlySpan{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a span of key/value tuples.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledDictionary``2(System.Span{System.ValueTuple{``0,``1}},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a <see cref="T:fx.Collections.PooledDictionary`2"/> from a span of key/value tuples.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the collection to a new instance of <see cref="T:fx.Collections.PooledSet`1"/>,
            optionally using the given comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledSet``1(System.Span{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the collection to a new instance of <see cref="T:fx.Collections.PooledSet`1"/>,
            optionally using the given comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledSet``1(System.ReadOnlySpan{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the collection to a new instance of <see cref="T:fx.Collections.PooledSet`1"/>,
            optionally using the given comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledSet``1(System.Memory{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the collection to a new instance of <see cref="T:fx.Collections.PooledSet`1"/>,
            optionally using the given comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledSet``1(System.ReadOnlyMemory{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Converts the collection to a new instance of <see cref="T:fx.Collections.PooledSet`1"/>,
            optionally using the given comparer.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(``0[])">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(System.Span{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledStack``1(System.Memory{``0})">
            <summary>
            Creates an instance of PooledStack from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(System.Span{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(System.Memory{``0})">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledExtensions.ToPooledQueue``1(``0[])">
            <summary>
            Creates an instance of PooledQueue from the given items.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledList`1">
            <summary>
            Implements a variable-size list that uses a pooled array to store the
            elements. A PooledList has a capacity, which is the allocated length
            of the internal array. As elements are added to a PooledList, the capacity
            of the PooledList is automatically increased as required by reallocating the
            internal array.
            </summary>
            <remarks>
            This class is based on the code for <see cref="T:System.Collections.Generic.List`1"/> but it supports <see cref="T:System.Span`1"/>
            and uses <see cref="T:System.Buffers.ArrayPool`1"/> when allocating internal arrays.
            </remarks>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(fx.Collections.ClearMode)">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
            <param name="capacity">The intial capacity of the list.</param>
            <param name="clearMode">Determines whether values are cleared before returning them to the ArrayPool. See <see cref="!:Pooled.ClearMode"/> for more details.</param>
            <param name="customPool">A custom ArrayPool to use when allocating internal arrays.</param>
            <param name="sizeToCapacity">If true, Count of list equals capacity. Depending on ClearMode, rented items may or may not hold dirty values.</param>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(`0[])">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(`0[],fx.Collections.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(`0[],fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode)">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a PooledList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.Span">
            <summary>
            Gets a <see cref="T:System.Span`1"/> for the items currently in the collection.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.Span`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.fx#Collections#IReadOnlyPooledList{T}#Span">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> for the items currently in the collection.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.ReadOnlySpan`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.Capacity">
            <summary>
            Gets and sets the capacity of this list.  The capacity is the size of
            the internal array used to hold items.  When set, the internal 
            Memory of the list is reallocated to the given capacity.
            Note that the return value for this property may be larger than the property was set to.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.Count">
            <summary>
            Read-only property describing how many elements are in the List.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the given index.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Add(`0)">
            <summary>
            Adds the given object to the end of this list. The size of the list is
            increased by one. If required, the capacity of the list is doubled
            before adding the new element.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the given collection to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.AddRange(`0[])">
            <summary>
            Adds the elements of the given array to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.AddRange(System.ReadOnlySpan{`0})">
            <summary>
            Adds the elements of the given <see cref="T:System.ReadOnlySpan`1"/> to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.AddSpan(System.Int32)">
            <summary>
            Advances the <see cref="P:fx.Collections.PooledList`1.Count"/> by the number of items specified,
            increasing the capacity if required, then returns a <see cref="T:System.Span`1"/> representing
            the set of items to be added, allowing direct writes to that section
            of the collection.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.Span`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
            <param name="count">The number of items to add.</param>
        </member>
        <member name="M:fx.Collections.PooledList`1.AsReadOnly">
            <summary>
            Returns a read-only version of the current list.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
             <summary>
             Searches a section of the list for a given element using a binary search
             algorithm. 
             </summary>
             
             <remarks><para>Elements of the list are compared to the search value using
             the given IComparer interface. If comparer is null, elements of
             the list are compared to the search value using the IComparable
             interface, which in that case must be implemented by all elements of the
             list and the given search value. This method assumes that the given
             section of the list is already sorted; if this is not the case, the
             result will be incorrect.</para>
            
             <para>The method returns the index of the given value in the list. If the
             list does not contain the given value, the method returns a negative
             integer. The bitwise complement operator (~) can be applied to a
             negative result to produce the index of the first element (if any) that
             is larger than the given search value. This is also the index at which
             the search value should be inserted into the list in order for the list
             to remain sorted.
             </para></remarks>
        </member>
        <member name="M:fx.Collections.PooledList`1.BinarySearch(`0)">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Clear">
            <summary>
            Clears the contents of the PooledList.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Contains(`0)">
            <summary>
            Contains returns true if the specified element is in the List.
            It does a linear, O(n) search.  Equality is determined by calling
            EqualityComparer{T}.Default.Equals.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.ConvertAll``1(System.Func{`0,``0})">
            <summary>
            Creates a new instance of <see cref="T:fx.Collections.PooledList`1"/> containing
            the output of running the <paramref name="converter"/> function on each item
            in the current list.
            </summary>
            <typeparam name="TOutput">The type to convert the contents of this list to.</typeparam>
            <param name="converter">The function that converts each item in the current list.</param>
            <returns>A new instance of <see cref="T:fx.Collections.PooledList`1"/>.</returns>
        </member>
        <member name="M:fx.Collections.PooledList`1.CopyTo(System.Span{`0})">
            <summary>
            Copies this list to the given span.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the given minimum
            value. If the current capacity of the list is less than min, the
            capacity is increased to twice the current capacity or to min,
            whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Returns true if the given <paramref name="match"/> function returns true for any item in the list.
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.Find(System.Func{`0,System.Boolean})">
            <summary>
            The first item for which the given <paramref name="match"/> function returns true
            will be returned, or the default value of <typeparamref name="T"/> if no match is found.
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.TryFind(System.Func{`0,System.Boolean},`0@)">
            <summary>
            The first item for which the given <paramref name="match"/> function returns true
            will be returned in the <paramref name="result"/> output parameter. The method will
            return true if a match was found, otherwise false.
            </summary>
            <param name="match"></param>
            <param name="result"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Returns a new instance of <see cref="T:fx.Collections.PooledList`1"/> containing
            all of the items for which the <paramref name="match"/> function
            returns true.
            </summary>
            <param name="match">A predicate function that returns true for matches.</param>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the first occurrence within the <see cref="T:fx.Collections.PooledList`1"/>
            or a portion of it. This method returns -1 if an item that matches the conditions is not found.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindIndex(System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the first occurrence within the <see cref="T:fx.Collections.PooledList`1"/>
            or a portion of it. This method returns -1 if an item that matches the conditions is not found.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the first occurrence within the <see cref="T:fx.Collections.PooledList`1"/>
            or a portion of it. This method returns -1 if an item that matches the conditions is not found.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindLast(System.Predicate{`0})">
            <summary>
            The last item for which the given <paramref name="match"/> function returns true
            will be returned. If no match is found, the default value for <typeparamref name="T"/> is returned.
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.TryFindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            The last item for which the given <paramref name="match"/> function returns true
            will be returned in the <paramref name="result"/> output parameter. The method will
            return true if a match was found, otherwise false.
            </summary>
            <param name="match"></param>
            <param name="result"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the last occurrence within the <see cref="T:fx.Collections.PooledList`1"/> or a portion of it.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindLastIndex(System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the last occurrence within the <see cref="T:fx.Collections.PooledList`1"/> or a portion of it.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.FindLastIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by a specified predicate, 
            and returns the zero-based index of the last occurrence within the <see cref="T:fx.Collections.PooledList`1"/> or a portion of it.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.ForEach(System.Action{`0})">
            <summary>
            Passes each item in the list to the given <paramref name="action"/> function.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.ForEach(System.Action{`0,System.Int32})">
            <summary>
            Passes each item in the list and the item's index to the given <paramref name="action"/> function.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.GetEnumerator">
            <summary>
            Returns an enumerator for this list with the given
            permission for removal of elements. If modifications made to the list 
            while an enumeration is in progress, the MoveNext and 
            GetObject methods of the enumerator will throw an exception.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:System.Span`1"/> allowing read/write access to a subset of the entire list.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.Span`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.GetRange(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Span`1"/> starting from the given index and going to the end of the list.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.Span`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.IndexOf(`0)">
            <summary>
            Returns the index of the first occurrence of a given value in
            this list. The list is searched forwards from beginning to end.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.IndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and ending at count number of elements. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and upto count number of elements. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into this list at a given index. The size of the list
            is increased by one. If required, the capacity of the list is doubled
            before inserting the new element.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.InsertRange(System.Int32,System.ReadOnlySpan{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.InsertRange(System.Int32,`0[])">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.InsertSpan(System.Int32,System.Int32)">
            <summary>
            Inserts the given number of items at the given index, increasing the
            capacity if required, then returns a <see cref="T:System.Span`1"/> representing the set of items
            to be inserted, allowing direct writes to that section of the collection.
            WARNING: Be careful not to modify the list until you're finished with the returned 
            <see cref="T:System.Span`1"/>. Actions that change the size of the list will not affect
            the length of the Span, and may invalidate the Span entirely by making changes to the backing store.
            Continuing to use the Span after making changes to the PooledList is NOT guaranteed to work.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at the end 
            and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            index and up to count elements
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of the given item. The size of the list is
            decreased by one.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items which match the predicate.
            The complexity is O(n).
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index. The size of the list is
            decreased by one.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from this list.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Reverse">
            <summary>
            Reverses the elements in this list.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the elements in a range of this list. Following a call to this
            method, an element in the range given by index and count
            which was previously located at index i will now be located at
            index index + (index + count - i - 1).
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Sort">
            <summary>
            Sorts the elements in this list.  Uses the default comparer and 
            Array.Sort.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in this list.  Uses Array.Sort with the
            provided comparer.
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a section of this list. The sort compares the
            elements to each other using the given IComparer interface. If
            comparer is null, the elements are compared to each other using
            the IComparable interface, which in that case must be implemented by all
            elements of the list.
            
            This method uses the Array.Sort method to sort the elements.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in a section of this list. The sort compares the
            elements to each other using the given IComparer interface. If
            comparer is null, the elements are compared to each other using
            the IComparable interface, which in that case must be implemented by all
            elements of the list.
            
            This method uses the Array.Sort method to sort the elements.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.ToArray">
            <summary>
            ToArray returns an array containing the contents of the List.
            This requires copying the List, which is an O(n) operation.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list. This method can
            be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and
            release all memory referenced by the list, execute the following
            statements:
            <code>
            list.Clear();
            list.TrimExcess();
            </code>
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.TrueForAll(System.Func{`0,System.Boolean})">
            <summary>
            Returns true if all the items in the list return true
            for the given predicate function.
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:fx.Collections.PooledList`1.Dispose">
            <summary>
            Returns the internal buffers to the pool.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Dispose(System.Boolean)">
            <summary>
            Returns the internal buffers to the pool.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledList`1.Enumerator">
            <summary>
            An enumerator, for enumerating the <see cref="T:fx.Collections.PooledList`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledList`1.Enumerator.MoveNext">
            <summary>
            Advances to the next item in the list. Returns false if there are no more items.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledList`1.Enumerator.Current">
            <summary>
            Returns the current item.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledObservableCollection`1">
            <summary>
            Implementation of a dynamic data collection based on generic Collection&lt;T&gt;,
            implementing INotifyCollectionChanged to notify listeners
            when items get added, removed or the whole list is refreshed.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.#ctor">
            <summary>
            Initializes a new instance of ObservableCollection that is empty and has default initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the ObservableCollection class that contains
            elements copied from the specified collection and has sufficient capacity
            to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new list.</param>
            <remarks>
            The elements are copied onto the ObservableCollection in the
            same order they are read by the enumerator of the collection.
            </remarks>
            <exception cref="T:System.ArgumentNullException"> collection is a null reference </exception>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.Move(System.Int32,System.Int32)">
            <summary>
            Move item at oldIndex to newIndex.
            </summary>
        </member>
        <member name="E:fx.Collections.PooledObservableCollection`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>
            PropertyChanged event (per <see cref="T:System.ComponentModel.INotifyPropertyChanged" />).
            </summary>
        </member>
        <member name="E:fx.Collections.PooledObservableCollection`1.CollectionChanged">
            <summary>
            Occurs when the collection changes, either by adding or removing an item.
            </summary>
            <remarks>
            see <seealso cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>
            </remarks>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.ClearItems">
            <summary>
            Called by base class Collection&lt;T&gt; when the list is being cleared;
            raises a CollectionChanged event to any listeners.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.RemoveItem(System.Int32)">
            <summary>
            Called by base class Collection&lt;T&gt; when an item is removed from list;
            raises a CollectionChanged event to any listeners.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            Called by base class Collection&lt;T&gt; when an item is added to list;
            raises a CollectionChanged event to any listeners.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the items to the collection all at once, then fires change events to any listeners.
            </summary>
            <param name="items">The items to add. This collection will be iterated twice.</param>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.SetItem(System.Int32,`0)">
            <summary>
            Called by base class Collection&lt;T&gt; when an item is set in list;
            raises a CollectionChanged event to any listeners.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.MoveItem(System.Int32,System.Int32)">
            <summary>
            Called by base class ObservableCollection&lt;T&gt; when an item is to be moved within the list;
            raises a CollectionChanged event to any listeners.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Raises a PropertyChanged event (per <see cref="T:System.ComponentModel.INotifyPropertyChanged" />).
            </summary>
        </member>
        <member name="E:fx.Collections.PooledObservableCollection`1.PropertyChanged">
            <summary>
            PropertyChanged event (per <see cref="T:System.ComponentModel.INotifyPropertyChanged" />).
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raise CollectionChanged event to any listeners.
            Properties/methods modifying this ObservableCollection will raise
            a collection changed event through this virtual method.
            </summary>
            <remarks>
            When overriding this method, either call its base implementation
            or call <see cref="M:fx.Collections.PooledObservableCollection`1.BlockReentrancy"/> to guard against reentrant collection changes.
            </remarks>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.BlockReentrancy">
            <summary>
            Disallow reentrant attempts to change this collection. E.g. an event handler
            of the CollectionChanged event is not allowed to make changes to this collection.
            </summary>
            <remarks>
            typical usage is to wrap e.g. a OnCollectionChanged call with a using() scope:
            <code>
                    using (BlockReentrancy())
                    {
                        CollectionChanged(this, new NotifyCollectionChangedEventArgs(action, item, index));
                    }
            </code>
            </remarks>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.CheckReentrancy">
            <summary> Check and assert for reentrant attempts to change this collection. </summary>
            <exception cref="T:System.InvalidOperationException"> raised when changing the collection
            while another collection change is still being notified to other listeners </exception>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCountPropertyChanged">
            <summary>
            Helper to raise a PropertyChanged event for the Count property
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnIndexerPropertyChanged">
            <summary>
            Helper to raise a PropertyChanged event for the Indexer property
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32)">
            <summary>
            Helper to raise CollectionChanged event to any listeners
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Int32,System.Int32)">
            <summary>
            Helper to raise CollectionChanged event to any listeners
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedAction,System.Object,System.Object,System.Int32)">
            <summary>
            Helper to raise CollectionChanged event to any listeners
            </summary>
        </member>
        <member name="M:fx.Collections.PooledObservableCollection`1.OnCollectionReset">
            <summary>
            Helper to raise CollectionChanged event with action == Reset to any listeners
            </summary>
        </member>
        <member name="T:fx.Collections.PooledQueue`1">
            <summary>
            A simple Queue of generic objects.  Internally it is implemented as a 
            circular buffer, so Enqueue can be O(n).  Dequeue is O(1).
            </summary>
            <typeparam name="T">The type to store in the queue.</typeparam>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(fx.Collections.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that is empty and has the specified initial capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(`0[],fx.Collections.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(`0[],fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            array and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode)">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:fx.Collections.PooledQueue`1"/> class that contains elements copied from the specified 
            span and has sufficient capacity to accommodate the number of elements copied.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledQueue`1.Count">
            <summary>
            The number of items in the queue.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledQueue`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Clear">
            <summary>
            Removes all objects from the queue.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            CopyTo copies a collection into an Array, starting at a particular
            index into the array.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Enqueue(`0)">
            <summary>
            Adds <paramref name="item"/> to the tail of the queue.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.GetEnumerator">
            <summary>
            GetEnumerator returns an IEnumerator over this Queue.  This
            Enumerator will support removing.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Dequeue">
            <summary>
            Removes the object at the head of the queue and returns it. If the queue
            is empty, this method throws an 
            <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.TryDequeue(`0@)">
            <summary>
            Removes the object at the head of the queue and assigns it to <paramref name="result"/>, returning true.
            If the queue is empty, returns false and sets <paramref name="result"/> to the default value for <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Peek">
            <summary>
            Returns the object at the head of the queue. The object remains in the
            queue. If the queue is empty, this method throws an 
            <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.TryPeek(`0@)">
            <summary>
            Assigns the object at the head of the queue to <paramref name="result"/> without removing it, returning true.
            If the queue is empty, returns false and sets <paramref name="result"/> to the default value for <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Contains(`0)">
            <summary>
            Returns true if the queue contains at least one object equal to item.
            Equality is determined using <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items from the queue which match the predicate.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.ToArray">
            <summary>
            Iterates over the objects in the queue, returning an array of the
            objects in the Queue, or an empty array if the queue is empty.
            The order of elements in the array is first in to last in, the same
            order produced by successive calls to Dequeue.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:fx.Collections.PooledQueue`1"/>, 
            if that number is less than 90 percent of current capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Dispose">
            <summary>
            Returns the underlying storage to the pool and sets <see cref="P:fx.Collections.PooledQueue`1.Count"/> to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets <see cref="P:fx.Collections.PooledQueue`1.Count"/> to zero.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledQueue`1.Enumerator">
            <summary>
            Implements an enumerator for a Queue.  The enumerator uses the
            internal version number of the queue to ensure that no modifications are
            made to the queue while an enumeration is in progress.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Enumerator.Dispose">
            <summary>
            Disposes the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledQueue`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.PooledQueue`1.Enumerator.Current">
            <summary>
            Returns the current item.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledSet`1">
            <summary>
            Represents a set of values.
            </summary>
            <remarks>
            Implementation notes:
            This uses an array-based implementation similar to <see cref="T:System.Collections.Generic.Dictionary`2"/>, using a buckets array
            to map hash values to the Slots array. Items in the Slots array that hash to the same value
            are chained together through the "next" indices. 
            
            The capacity is always prime; so during resizing, the capacity is chosen as the next prime
            greater than double the last capacity. 
            
            The underlying data structures are lazily initialized. Because of the observation that, 
            in practice, hashtables tend to contain only a few elements, the initial capacity is
            set very small (3 elements) unless the ctor with a collection is used.
            
            The +/- 1 modifications in methods that add, check for containment, etc allow us to 
            distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
            reset each bucket to -1 when resizing. See Contains, for example.
            
            Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
            this set.
            
            Some operations can perform faster if we can assume "other" contains unique elements
            according to this equality comparer. The only times this is efficient to check is if
            other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
            also have to check that the hashset is using the same equality comparer. If other 
            has a different equality comparer, it will have unique elements according to its own
            equality comparer, but not necessarily according to ours. Therefore, to go these 
            optimized routes we check that other is a hashset using the same equality comparer.
            
            A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
            special empty set checks.)
            
            A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
            If we didn't have these checks, we could be iterating over the set and modifying at
            the same time. 
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(`0[])">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(`0[],fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(`0[],System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(`0[],fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.ReadOnlySpan{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add item to this hashset. This is the explicit implementation of the <see cref="T:System.Collections.Generic.ICollection`1"/>
            interface. The other Add method returns bool indicating whether item was added.
            </summary>
            <param name="item">item to add</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="P:fx.Collections.PooledSet`1.Count">
            <summary>
            Number of elements in this set
            </summary>
        </member>
        <member name="P:fx.Collections.PooledSet`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.GetEnumerator">
            <summary>
            Gets an enumerator with which to enumerate the set.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets object data for serialization.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.OnDeserialization(System.Object)">
            <summary>
            Deserialization callback.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Add(`0)">
            <summary>
            Add item to this PooledSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.TryGetValue(`0,`0@)">
            <summary>
            Searches the set for a given value and returns the equal value it finds, if any.
            </summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of 
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:fx.Collections.PooledSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            </summary>
            <remarks>
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </remarks>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.UnionWith(`0[])">
            <summary>
            Take the union of this PooledSet with other. Modifies this set.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.UnionWith(System.ReadOnlySpan{`0})">
            <summary>
            Take the union of this PooledSet with other. Modifies this set.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            We get better perf if other is a hashset using same equality comparer, because we 
            get constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
            If we can't go above route, iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWith(`0[])">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            Iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWith(System.ReadOnlySpan{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            </summary>
            <remarks>
            Implementation Notes: 
            Iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </remarks>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.ExceptWith(`0[])">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.ExceptWith(System.ReadOnlySpan{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWith(`0[])">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">array with items to XOR</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWith(System.ReadOnlySpan{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">span with items to XOR</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a subset of anything, including the empty set
            2. If other has unique elements according to this equality comparer, and this has more
            elements than other, then it can't be a subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSubsetOf(`0[])">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSubsetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a subset of other.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            2. If other has unique elements according to this equality comparer, and this has >=
            the number of elements in other, then this can't be a proper subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSubsetOf(`0[])">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSubsetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSupersetOf(`0[])">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSupersetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a superset of other
            </summary>
            <remarks>
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            3. If other has unique elements according to this equality comparer, and other's count
            is greater than or equal to this count, then this can't be a proper superset
            
            Furthermore, if other has unique elements according to this equality comparer, we can
            use a faster element-wise check.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSupersetOf(`0[])">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsProperSupersetOf(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            </summary>
            <remarks>
            Implementation Notes: 
            This is slightly more complicated than IsSupersetOf because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            </remarks>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Overlaps(`0[])">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Overlaps(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SetEquals(`0[])">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SetEquals(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CopyTo(`0[])">
            <summary>
            Copies the set to the given array.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies <paramref name="count"/> items of the set to the given array, starting 
            at <paramref name="arrayIndex"/> in the destination array.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CopyTo(System.Span{`0})">
            <summary>
            Copies the set to the given span.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CopyTo(System.Span{`0},System.Int32)">
            <summary>
            Copies <paramref name="count"/> items from the set to the given span.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.PooledSet`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the hash set can hold up to 'capacity' entries without any further expansion of its backing storage.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CreateSetComparer">
            <summary>
            Used for deep equality of HashSet testing
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SetCapacity(System.Int32)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.ContainsAllElements(System.ReadOnlySpan{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSubsetOfHashSetWithSameEC(fx.Collections.PooledSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWithHashSetWithSameEC(fx.Collections.PooledSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.IntersectWithSpan(System.ReadOnlySpan{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWithUniqueHashSet(fx.Collections.PooledSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.SymmetricExceptWithSpan(System.ReadOnlySpan{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.CheckUniqueAndUnfoundElements(System.ReadOnlySpan{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is a Span and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.PooledSetEquals(fx.Collections.PooledSet{`0},fx.Collections.PooledSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.AreEqualityComparersEqual(fx.Collections.PooledSet{`0},fx.Collections.PooledSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.AreEqualityComparersEqual(fx.Collections.PooledSet{`0},System.Collections.Generic.HashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
        </member>
        <member name="M:fx.Collections.PooledSet`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Dispose">
            <summary>
            Clears all values and returns internal arrays to the ArrayPool.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Dispose(System.Boolean)">
            <summary>
            Clears all values and returns internal arrays to the ArrayPool.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledSet`1.Enumerator">
            <summary>
            Enumerates the PooledSet.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledSet`1.Enumerator.MoveNext">
            <summary>
            Moves to the next item in the set.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledSet`1.Enumerator.Current">
            <summary>
            Gets the current element in the set.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledSetEqualityComparer`1">
            <summary>
            Equality comparer for hashsets of hashsets
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:fx.Collections.PooledStack`1">
            <summary>
            A simple stack of objects.  Internally it is implemented as an array,
            so Push can be O(n).  Pop is O(1).
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(fx.Collections.ClearMode)">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with the default initial capacity. 
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with the default initial capacity and a custom ArrayPool.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Int32)">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Create a stack with a specific initial capacity.  The initial capacity
            must be a non-negative number.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(`0[])">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(`0[],fx.Collections.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(`0[],fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode)">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Fills a Stack with the contents of a particular collection.  The items are
            pushed onto the stack in the same order they are read by the enumerator.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledStack`1.Count">
            <summary>
            The number of items in the stack.
            </summary>
        </member>
        <member name="P:fx.Collections.PooledStack`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Clear">
            <summary>
            Removes all Objects from the Stack.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Contains(`0)">
            <summary>
            Compares items using the default equality comparer
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.RemoveWhere(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items which match the predicate.
            The complexity is O(n).
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the stack into an array.</summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.CopyTo(System.Span{`0})">
            <summary>Copies the stack into a span.</summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.GetEnumerator">
            <summary>
            Returns an IEnumerator for this PooledStack.
            </summary>
            <returns></returns>
        </member>
        <member name="M:fx.Collections.PooledStack`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="M:fx.Collections.PooledStack`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:fx.Collections.PooledStack`1"/>, 
            if that number is less than 90 percent of current capacity.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Peek">
            <summary>
            Returns the top object on the stack without removing it.  If the stack
            is empty, Peek throws an InvalidOperationException.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.TryPeek(`0@)">
            <summary>
                If the stack is not empty returns true and sets the <paramref name="result"/> parameter
                to the value of the top object on the <see cref="T:fx.Collections.PooledStack`1"/> without removing it.
                If the stack is empty, returns false and sets <paramref name="result"/> to the default
                value for <typeparamref name="T"/>.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Pop">
            <summary>
            Pops an item from the top of the stack.  If the stack is empty, Pop
            throws an InvalidOperationException.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.TryPop(`0@)">
            <summary>
                If the stack is not empty returns true and sets the <paramref name="result"/> parameter
                to the value of the top object on the <see cref="T:fx.Collections.PooledStack`1"/> after removing it.
                If the stack is empty, returns false and sets <paramref name="result"/> to the default
                value for <typeparamref name="T"/>.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Push(`0)">
            <summary>
            Pushes an item to the top of the stack.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.ToArray">
            <summary>
            Copies the Stack to an array, in the same order Pop would return the items.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Reverse">
            <summary>
            Reverses the stack. Useful when loading from saved state.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Dispose">
            <summary>
            Returns the underlying storage to the pool and sets <see cref="P:fx.Collections.PooledStack`1.Count"/> to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets <see cref="P:fx.Collections.PooledStack`1.Count"/> to zero.
            </summary>
        </member>
        <member name="T:fx.Collections.PooledStack`1.Enumerator">
            <summary>
            Enumerates the <see cref="T:fx.Collections.PooledStack`1"/>.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Enumerator.Dispose">
            <summary>
            Disposes the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.PooledStack`1.Enumerator.MoveNext">
            <summary>
            Advances the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.PooledStack`1.Enumerator.Current">
            <summary>
            Returns the current item.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2">
            <remarks>
            A <see cref="T:fx.Collections.RefPDictionary`2"/> can support multiple readers concurrently, as long as the collection is not modified. 
            Even so, enumerating through a collection is intrinsically not a thread-safe procedure. 
            In the rare case where an enumeration contends with write accesses, the collection must be locked during the entire enumeration. 
            To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization. 
            </remarks>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:fx.Collections.RefPDictionary`2"/>.
            </summary>
        </member>
        <member name="F:fx.Collections.RefPDictionary`2.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:fx.Collections.RefPDictionary`2.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:fx.Collections.RefPDictionary`2.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Int32,fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ValueTuple{`0,`1}[])">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ValueTuple{`0,`1}[],fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ValueTuple{`0,`1}[],System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ValueTuple{`0,`1}[],fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},fx.Collections.ClearMode)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.ReadOnlySpan{System.ValueTuple{`0,`1}},fx.Collections.ClearMode,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates a new instance of RefPDictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Comparer">
            <summary>
            The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used to compare keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Count">
            <summary>
            The number of items in the dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.KeyClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.ValueClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Keys">
            <summary>
            The keys in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Values">
            <summary>
            The values in this dictionary.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Item(`0)">
            <summary>
            Gets or sets an item in the dictionary by key.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Add(`0,`1)">
            <summary>
            Adds a key/value pair to the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddRange(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddRange(System.ValueTuple{`0,`1}[])">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, an exception is thrown.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.SetRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.SetRange(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.SetRange(System.ReadOnlySpan{System.ValueTuple{`0,`1}})">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.SetRange(System.ValueTuple{`0,`1}[])">
            <summary>
            Adds a set of key-value pairs to the dictionary. If any of the keys are already
            present, the existing value is overwritten.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the dictionary. If the key is already present, the <paramref name="updater"/>
            function is called, with the key and the current value as parameters. The value returned from this function
            will overwrite the current value.
            </summary>
            <param name="key"></param>
            <param name="addValue"></param>
            <param name="updater"></param>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the dictionary. If the key is not already present, the <paramref name="addValueFactory"/>
            function is called to generate the value for the key in question. 
            If the key is already present, the <paramref name="updater"/> function is called, with the key and
            the current value as parameters. The value returned from this function will overwrite the current value.
            </summary>
            <param name="key"></param>
            <param name="addValueFactory"></param>
            <param name="updater"></param>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if the dictionary contains the given key.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ContainsValue(`1)">
            <summary>
            Returns true if the dictionary contains the given value.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Allows child classes to add their own serialization data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.OnDeserialization(System.Object)">
            <summary>
            Called during deserialization.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Remove(`0)">
            <summary>
            Removes the item with the given key.
            Returns true if the key was found and the value successfully removed.
            </summary>
            <param name="key">The key</param>
            <returns>Returns true if the key was found and removed.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Remove(`0,`1@)">
            <summary>
            Removes the item with the given key.
            If the key was found, returns true and sets the <paramref name="value"/> parameter to the removed value.
            If the key was not found, returns false and sets the <paramref name="value"/> parameter to the default value for the type.
            </summary>
            <param name="key">The key</param>
            <param name="value">The removed value</param>
            <returns>Returns true if the key was found and removed.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value corresponding to the given key.
            If the key was found, returns true and sets the <paramref name="value"/> parameter to the corresponding value.
            If the key was not found, returns false and sets the <paramref name="value"/> to the default value for the type.
            </summary>
            <param name="key">The key</param>
            <param name="value">The returned value</param>
            <returns>True if the key was found, otherwise false.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the given key-value pair, if the key was not already present.
            </summary>
            <param name="key">The key</param>
            <param name="value">The value to add</param>
            <returns>Returns true if the value was successfully added, false if the key was already present and the value was not added.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Gets the current value associated with the given key. If the key was not found,
            adds <paramref name="addValue"/> with the given key and returns it.
            </summary>
            <param name="key">The key</param>
            <param name="addValue">The value to add if the key was not found</param>
            <returns>Either the current value or the just-added value.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Gets the current value associated with the given key. If the key was not found,
            runs <paramref name="valueFactory"/> and adds the result with the given key, returning the newly-added value.
            </summary>
            <param name="key">The key</param>
            <param name="valueFactory">A function that will be used to generate a value to add if the key was not found</param>
            <returns>Either the current value or the just-added value.</returns>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            
            To allocate minimum size storage array, execute the following statements:
            
            dictionary.Clear();
            dictionary.TrimExcess();
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added. 
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Dispose">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Dispose(System.Boolean)">
            <summary>
            Returns the underlying storage to the pool and sets the Count to zero.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.Enumerator">
            <summary>
            Enumerates dictionary keys and values.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.Enumerator.MoveNext">
            <summary>
            Moves to the next item, returning false if there are no more items.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.Enumerator.Current">
            <summary>
            The current item.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.KeyCollection">
            <summary>
            A collection of dictionary keys.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.KeyCollection.#ctor(fx.Collections.RefPDictionary{`0,`1})">
            <summary>
            Creates an instance of a KeyCollection
            </summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.KeyCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.KeyCollection.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the dictionary keys to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.KeyCollection.CopyTo(System.Span{`0})">
            <summary>
             Copies the dictionary keys to a span.
            </summary>
            <param name="span"></param>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.KeyCollection.Count">
            <summary>
            The number of items in the collection.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.KeyCollection.Enumerator">
            <summary>
            The enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.KeyCollection.Enumerator.MoveNext">
            <summary>
            Moves to the next value, returning false if there are no more values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.KeyCollection.Enumerator.Current">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.ValueCollection">
            <summary>
            A collection of dicationary values.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ValueCollection.#ctor(fx.Collections.RefPDictionary{`0,`1})">
            <summary>
            Creates an instance of ValueCollection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ValueCollection.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ValueCollection.CopyTo(`1[],System.Int32)">
            <summary>
            Copies the dictionary values to an array.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ValueCollection.CopyTo(System.Span{`1})">
            <summary>
            Copies the dictionary values to the given span.
            </summary>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.ValueCollection.Count">
            <summary>
            The count of items.
            </summary>
        </member>
        <member name="T:fx.Collections.RefPDictionary`2.ValueCollection.Enumerator">
            <summary>
            A dictionary enumerator.
            </summary>
        </member>
        <member name="M:fx.Collections.RefPDictionary`2.ValueCollection.Enumerator.MoveNext">
            <summary>
            Moves to the next value, returning false if there are no more values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:fx.Collections.RefPDictionary`2.ValueCollection.Enumerator.Current">
            <summary>
            Returns the current value.
            </summary>
        </member>
        <member name="T:fx.Collections.RefpList`1">
            <summary>
            Implements a variable-size list that uses a pooled array to store the
            elements. A RefpList has a capacity, which is the allocated length
            of the internal array. As elements are added to a RefpList, the capacity
            of the RefpList is automatically increased as required by reallocating the
            internal array.
            </summary>
            <remarks>
            This class is based on the code for <see cref="T:System.Collections.Generic.List`1"/> but it supports <see cref="T:System.Span`1"/>
            and uses <see cref="T:System.Buffers.ArrayPool`1"/> when allocating internal arrays.
            </remarks>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor">
            <summary>
            Constructs a RefpList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(fx.Collections.ClearMode)">
            <summary>
            Constructs a RefpList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList. The list is initially empty and has a capacity
            of zero. Upon adding the first element to the list the capacity is
            increased to DefaultCapacity, and then increased in multiples of two
            as required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,fx.Collections.ClearMode)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Int32,fx.Collections.ClearMode,System.Buffers.ArrayPool{`0},System.Boolean)">
            <summary>
            Constructs a List with a given initial capacity. The list is
            initially empty, but will have room for the given number of elements
            before any reallocations are required.
            </summary>
            <param name="sizeToCapacity">If true, Count of list equals capacity. Depending on ClearMode, rented items may or may not hold dirty values.</param>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(`0[])">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(`0[],fx.Collections.ClearMode)">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(`0[],System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(`0[],fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode)">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.ReadOnlySpan{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.ReadOnlySpan{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode)">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.#ctor(System.Collections.Generic.IEnumerable{`0},fx.Collections.ClearMode,System.Buffers.ArrayPool{`0})">
            <summary>
            Constructs a RefpList, copying the contents of the given collection. The
            size and capacity of the new list will both be equal to the size of the
            given collection.
            </summary>
        </member>
        <member name="P:fx.Collections.RefpList`1.Span">
            <summary>
            Gets a <see cref="T:System.Span`1"/> for the items currently in the collection.
            </summary>
        </member>
        <member name="P:fx.Collections.RefpList`1.Capacity">
            <summary>
            Gets and sets the capacity of this list.  The capacity is the size of
            the internal array used to hold items.  When set, the internal 
            Memory of the list is reallocated to the given capacity.
            Note that the return value for this property may be larger than the property was set to.
            </summary>
        </member>
        <member name="P:fx.Collections.RefpList`1.Count">
            <summary>
            Read-only property describing how many elements are in the List.
            </summary>
        </member>
        <member name="P:fx.Collections.RefpList`1.ClearMode">
            <summary>
            Returns the ClearMode behavior for the collection, denoting whether values are
            cleared from internal arrays before returning them to the pool.
            </summary>
        </member>
        <member name="P:fx.Collections.RefpList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the given index.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Add(`0)">
            <summary>
            Adds the given object to the end of this list. The size of the list is
            increased by one. If required, the capacity of the list is doubled
            before adding the new element.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the given collection to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.AddRange(`0[])">
            <summary>
            Adds the elements of the given array to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.AddRange(System.ReadOnlySpan{`0})">
            <summary>
            Adds the elements of the given <see cref="T:System.ReadOnlySpan`1"/> to the end of this list. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.AddSpan(System.Int32)">
            <summary>
            Advances the <see cref="P:fx.Collections.RefpList`1.Count"/> by the number of items specified,
            increasing the capacity if required, then returns a Span representing
            the set of items to be added, allowing direct writes to that section
            of the collection.
            </summary>
            <param name="count">The number of items to add.</param>
        </member>
        <member name="M:fx.Collections.RefpList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
             <summary>
             Searches a section of the list for a given element using a binary search
             algorithm. 
             </summary>
             
             <remarks><para>Elements of the list are compared to the search value using
             the given IComparer interface. If comparer is null, elements of
             the list are compared to the search value using the IComparable
             interface, which in that case must be implemented by all elements of the
             list and the given search value. This method assumes that the given
             section of the list is already sorted; if this is not the case, the
             result will be incorrect.</para>
            
             <para>The method returns the index of the given value in the list. If the
             list does not contain the given value, the method returns a negative
             integer. The bitwise complement operator (~) can be applied to a
             negative result to produce the index of the first element (if any) that
             is larger than the given search value. This is also the index at which
             the search value should be inserted into the list in order for the list
             to remain sorted.
             </para></remarks>
        </member>
        <member name="M:fx.Collections.RefpList`1.BinarySearch(`0)">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the list for a given element using a binary search
            algorithm. If the item implements <see cref="T:System.IComparable`1"/>
            then that is used for comparison, otherwise <see cref="P:System.Collections.Generic.Comparer`1.Default"/> is used.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Clear">
            <summary>
            Clears the contents of the RefpList.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Contains(`0)">
            <summary>
            Contains returns true if the specified element is in the List.
            It does a linear, O(n) search.  Equality is determined by calling
            EqualityComparer{T}.Default.Equals.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.CopyTo(System.Span{`0})">
            <summary>
            Copies this list to the given span.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the given minimum
            value. If the current capacity of the list is less than min, the
            capacity is increased to twice the current capacity or to min,
            whichever is larger.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.GetEnumerator">
            <summary>
            Returns an enumerator for this list with the given
            permission for removal of elements. If modifications made to the list 
            while an enumeration is in progress, the MoveNext and 
            GetObject methods of the enumerator will throw an exception.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.GetRange(System.Int32,System.Int32)">
            <summary>
            Equivalent to RefpList.Span.Slice(index, count).
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.IndexOf(`0)">
            <summary>
            Returns the index of the first occurrence of a given value in
            this list. The list is searched forwards from beginning to end.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.IndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and ending at count number of elements. 
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the first occurrence of a given value in a range of
            this list. The list is searched forwards, starting at index
            index and upto count number of elements. 
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element into this list at a given index. The size of the list
            is increased by one. If required, the capacity of the list is doubled
            before inserting the new element.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.InsertRange(System.Int32,System.ReadOnlySpan{`0})">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.InsertRange(System.Int32,`0[])">
            <summary>
            Inserts the elements of the given collection at a given index. If
            required, the capacity of the list is increased to twice the previous
            capacity or the new size, whichever is larger.  Ranges may be added
            to the end of the list by setting index to the List's size.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.InsertSpan(System.Int32,System.Int32)">
            <summary>
            Advances the <see cref="P:fx.Collections.RefpList`1.Count"/> by the number of items specified,
            increasing the capacity if required, then returns a Span representing
            the set of items to be added, allowing direct writes to that section
            of the collection.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.LastIndexOf(`0)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at the end 
            and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.LastIndexOf(`0,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            index and ending at the first element in the list.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>
            Returns the index of the last occurrence of a given value in a range of
            this list. The list is searched backwards, starting at index
            index and upto count elements
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            This method removes all items which match the predicate.
            The complexity is O(n).
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the given index. The size of the list is
            decreased by one.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of elements from this list.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Reverse">
            <summary>
            Reverses the elements in this list.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Reverse(System.Int32,System.Int32)">
            <summary>
            Reverses the elements in a range of this list. Following a call to this
            method, an element in the range given by index and count
            which was previously located at index i will now be located at
            index index + (index + count - i - 1).
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Sort">
            <summary>
            Sorts the elements in this list.  Uses the default comparer and 
            Array.Sort.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in this list.  Uses Array.Sort with the
            provided comparer.
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:fx.Collections.RefpList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the elements in a section of this list. The sort compares the
            elements to each other using the given IComparer interface. If
            comparer is null, the elements are compared to each other using
            the IComparable interface, which in that case must be implemented by all
            elements of the list.
            
            This method uses the Array.Sort method to sort the elements.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.ToArray">
            <summary>
            ToArray returns an array containing the contents of the List.
            This requires copying the List, which is an O(n) operation.
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list. This method can
            be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and
            release all memory referenced by the list, execute the following
            statements:
            <code>
            list.Clear();
            list.TrimExcess();
            </code>
            </summary>
        </member>
        <member name="M:fx.Collections.RefpList`1.Dispose">
            <summary>
            Returns the internal buffers to the ArrayPool.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.IUpgradeableLock">
            <summary>
            Interface implemented by ReaderWriterLocks' result to the UpgradeableLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.IUpgradeableLock.DisposableUpgrade">
            <summary>
            Upgrades this lock to a write-lock, returning an object so you can return to the upgradeable lock mode.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.IUpgradeableLock.Upgrade">
            <summary>
            Upgrades this lock to an write lock, but it is not possible to return to the upgradeable lock any more. At the end,
            both the upgradeable and the write-lock will be released.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.OptimisticReadLock">
            <summary>
            Class returned by ReadLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.OptimisticReadLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.OptimisticUpgradeableLock">
            <summary>
            Class returned by UpgradeableLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.OptimisticUpgradeableLock.DisposableUpgrade">
            <summary>
            Upgrades this lock to a write-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.OptimisticUpgradeableLock.Upgrade">
            <summary>
            Upgrades the lock to a write-lock. Returns true if the lock was upgraded, false if it was already upgraded
            before.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.OptimisticUpgradeableLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.OptimisticWriteLock">
            <summary>
            Class returned by WriteLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.OptimisticWriteLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.SpinReadLock">
            <summary>
            Class returned by ReadLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.SpinReadLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.SpinUpgradeableLock">
            <summary>
            Class returned by UpgradeableLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.SpinUpgradeableLock.DisposableUpgrade">
            <summary>
            Upgrades this lock to a write-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.SpinUpgradeableLock.Upgrade">
            <summary>
            Upgrades the lock to a write-lock. Returns true if the lock was upgraded, false if it was already upgraded
            before.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.SpinUpgradeableLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.Disposers.SpinWriteLock">
            <summary>
            Class returned by WriteLock method.
            </summary>
        </member>
        <member name="M:fx.Collections.Disposers.SpinWriteLock.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:fx.Collections.IEventWait">
            <summary>
            Interface implemented by PooledEventWait. And, thanks to StructuralCaster, can be used to access custom
            EventWait objects.
            </summary>
        </member>
        <member name="M:fx.Collections.IEventWait.WaitOne">
            <summary>
            Waits for this event to be signalled.
            </summary>
        </member>
        <member name="M:fx.Collections.IEventWait.WaitOne(System.Int32)">
            <summary>
            Waits for this event to be signalled or times-out. Returns if the object was signalled.
            </summary>
        </member>
        <member name="M:fx.Collections.IEventWait.WaitOne(System.TimeSpan)">
            <summary>
            Waits for this event to be signalled or times-out. Returns if the object was signalled.
            </summary>
        </member>
        <member name="M:fx.Collections.IEventWait.Reset">
            <summary>
            Resets (unsignals) this wait event.
            </summary>
        </member>
        <member name="M:fx.Collections.IEventWait.Set">
            <summary>
            Sets (signals) this wait event.
            </summary>
        </member>
        <member name="T:fx.Collections.IReaderWriterLock">
            <summary>
            Defines the contract that ReaderWriterLocks must follow. Note that if you want an Enter/Exit pair, you should
            use the IReaderWriterLockSlim.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLock.ReadLock">
            <summary>
            Obtains a read lock. You should use it in a using clause so at the end the lock is released.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLock.UpgradeableLock">
            <summary>
            Obtains an upgradeable lock. You can use the returned value to upgrade the lock. Also, you should dispose the
            returned object (an using block is preferreable) to release the lock.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLock.WriteLock">
            <summary>
            Obtains an write lock. Call this method in a using clause so the lock is released at the end.
            </summary>
        </member>
        <member name="T:fx.Collections.IReaderWriterLockSlim">
            <summary>
            Interface that must be implemented by reader-writer lock classes that are "slim". That is, they have Enter/Exit
            methods instead of returning disposable instances (which makes them faster, but more error prone).
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.EnterReadLock">
            <summary>
            Enters a read lock. Many readers can enter the read lock at the same time.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.ExitReadLock">
            <summary>
            Exits a previously entered read lock.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.EnterUpgradeableLock">
            <summary>
            Enters an upgradeable read lock. Many read locks can be obtained at the same time that a single upgradeable read
            lock is active, but two upgradeable or an upgradeable and an write lock are not permitted.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.ExitUpgradeableLock(System.Boolean)">
            <summary>
            Exits a previously entered upgradeable read lock. You should pass the boolean telling if the lock was upgraded or
            not.
            </summary>
            <param name="upgraded"></param>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.UncheckedExitUpgradeableLock">
            <summary>
            Exits an upgradeable read lock, considering it was never upgraded.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.UncheckedUpgradeToWriteLock">
            <summary>
            Upgraded a previously obtained upgradeable lock to a write lock, but does not check if the lock was already
            upgraded.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.UpgradeToWriteLock(System.Boolean@)">
            <summary>
            Upgraded the upgradeable lock to a write lock, checking if it was already upgraded or not (and also updating the
            upgraded boolean). To upgrade, the lock will wait all readers to end.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.UncheckedExitUpgradedLock">
            <summary>
            Exits an upgradeable lock that was also upgraded in a single task.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.EnterWriteLock">
            <summary>
            Enters a write lock. That is, the lock will only be obtained when there are no readers, be them upgradeable or not.
            </summary>
        </member>
        <member name="M:fx.Collections.IReaderWriterLockSlim.ExitWriteLock">
            <summary>
            Exits a previously obtained write lock.
            </summary>
        </member>
        <member name="T:fx.Collections.ManagedAutoResetEvent">
            <summary>
            An auto reset event that uses only Monitor methods to work, avoiding operating system events.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.#ctor">
            <summary>
            Creates a new event, not signaled.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates a new event, letting you say if it starts signaled or not.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.Dispose">
            <summary>
            Disposes this event. After disposing, it is always set. Calling Reset will not work and it will not throw
            exceptions, so you can dispose it when there are threads waiting on it.
            </summary>
        </member>
        <member name="P:fx.Collections.ManagedAutoResetEvent.WasDisposed">
            <summary>
            Gets a value indicating if this event was disposed.
            </summary>
        </member>
        <member name="P:fx.Collections.ManagedAutoResetEvent.IsSet">
            <summary>
            Gets a value indicating if this auto-reset event is set.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.Reset">
            <summary>
            Resets this event (makes it non-signaled).
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.Set">
            <summary>
            Signals the event, releasing one thread waiting on it.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.WaitOne">
            <summary>
            Waits until this event is signaled.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.WaitOne(System.Int32)">
            <summary>
            Waits until this event is signaled or until the timeout arrives. Return of true means it was signaled, false
            means timeout.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedAutoResetEvent.WaitOne(System.TimeSpan)">
            <summary>
            Waits until this event is signaled or until the timeout arrives. Return of true means it was signaled, false
            means timeout.
            </summary>
        </member>
        <member name="T:fx.Collections.ManagedManualResetEvent">
            <summary>
            A manual reset event that uses only Monitor methods to work, avoiding operating system events.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.#ctor">
            <summary>
            Creates a new event, not signaled.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates a new event, letting you say if it starts signaled or not.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.Dispose">
            <summary>
            Disposes this event. After disposing, it is always set. Calling Reset will not work and it will not throw
            exceptions, so you can dispose it when there are threads waiting on it.
            </summary>
        </member>
        <member name="P:fx.Collections.ManagedManualResetEvent.WasDisposed">
            <summary>
            Gets a value indicating if this event was disposed.
            </summary>
        </member>
        <member name="P:fx.Collections.ManagedManualResetEvent.IsSet">
            <summary>
            Gets a value indicating if this auto-reset event is set.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.Reset">
            <summary>
            Resets this event (makes it non-signaled).
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.Set">
            <summary>
            Signals the event, releasing any threads waiting on it.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.WaitOne">
            <summary>
            Waits until this event is signaled.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.WaitOne(System.Int32)">
            <summary>
            Waits until this event is signaled or until the timeout arrives. Return of true means it was signaled, false
            means timeout.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedManualResetEvent.WaitOne(System.TimeSpan)">
            <summary>
            Waits until this event is signaled or until the timeout arrives. Return of true means it was signaled, false
            means timeout.
            </summary>
        </member>
        <member name="T:fx.Collections.ManagedSemaphore">
            <summary>
            A semaphore class that uses only Monitor class for synchronization, avoiding operating system events.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.#ctor(System.Int32)">
            <summary>
            Creates a new semaphore with the given availableCount.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.Dispose">
            <summary>
            Disposes this semaphore. If you try to enter or exit it after this, the action will always return
            immediately.
            </summary>
        </member>
        <member name="P:fx.Collections.ManagedSemaphore.WasDisposed">
            <summary>
            Gets a value indicating if this semaphore was disposed.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.Enter">
            <summary>
            Enters the actual semaphore.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.Enter(System.Int32)">
            <summary>
            Enters the actual semaphore with the given count value. If you pass a value higher than the one used to
            create it, you will dead-lock (at least until the semaphore is disposed).
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.Exit">
            <summary>
            Exits the semaphore. One thread can enter it and another one exit it. There is no check for that.
            </summary>
        </member>
        <member name="M:fx.Collections.ManagedSemaphore.Exit(System.Int32)">
            <summary>
            Exits the semaphore the given amount. One thread can enter it and another one exit it. There is no check for
            that.
            </summary>
        </member>
        <member name="T:fx.Collections.OptimisticReaderWriterLock">
            <summary>
            An optimistic reader writer lock that is as fast as the  SpinReaderWriterLock/SpinReaderWriterLockSlim when the
            lock can be obtained immediately. But, if that's not the case, instead of spinning it will enter a real wait
            state. So, this one is preferreable if the locks are expected to be of large duration (100 milliseconds or more)
            while the SpinReaderWriterLock is preferreable if the waits are usually very small. Note that this class has
            both the Enter/Exit pairs (slim version) and the  methods that return a disposable object to release the lock
            (the non-slim version).
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.ReadLock">
            <summary>
            Acquires a read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.UpgradeableLock">
            <summary>
            Acquires a upgradeable read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.WriteLock">
            <summary>
            Acquires a write lock that must be used in a using clause. If you are using a UpgradeableLock use the
            Upgrade method of the YieldUpgradeableLock instead or you will cause a dead-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.EnterReadLock">
            <summary>
            Enters a read lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.ExitReadLock">
            <summary>
            Exits a read-lock. Take care not to exit more times than you entered, as there is no check for that.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.EnterUpgradeableLock">
            <summary>
            Enters an upgradeable lock (it is a read lock, but it can be upgraded). Only one upgradeable lock is allowed
            at a time.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.UncheckedExitUpgradeableLock">
            <summary>
            Exits a previously obtained upgradeable lock without verifying if it was upgraded or not.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.ExitUpgradeableLock(System.Boolean)">
            <summary>
            Exits a previously entered upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.UncheckedUpgradeToWriteLock">
            <summary>
            Upgrades to write-lock. You must already own a Upgradeable lock and you must first exit the write lock then
            the upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.UpgradeToWriteLock(System.Boolean@)">
            <summary>
            upgrades to write-lock. You must already own a Upgradeable lock and you must first exit the write lock then
            the Upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.UncheckedExitUpgradedLock">
            <summary>
            Releases the Upgradeable lock and the upgraded version of it (the write lock) at the same time. Releasing
            the write lock and the upgradeable lock has the same effect, but it's slower.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.EnterWriteLock">
            <summary>
            Enters write-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.OptimisticReaderWriterLock.ExitWriteLock">
            <summary>
            Exits write lock. Take care to exit only when you entered, as there is no check for that.
            </summary>
        </member>
        <member name="T:fx.Collections.SpinLockSlim">
            <summary>
            A real slim SpinWait (the Microsoft version is slower than the normal use of the lock keyword for uncontended
            locks). This lock never verifies ownership, so it will dead-lock if you try to enter it twice and it will allow
            one thread to enter the lock and another thread to release it (if you want that, it will be great... if not, you
            will be causing bugs). It should only be used in situations where the lock is expected to be held for very short
            times and when performance is really critical. This is a struct, so if you for some reason need to pass it as a
            parameter, use it as a ref, or else you will end-up using a copy of the lock instead of working on the real one.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinLockSlim.Enter">
            <summary>
            Enters the lock. So you can do your actions in a safe manner.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinLockSlim.Exit">
            <summary>
            Exits the lock. If the same thread exits and enters the lock constantly, it will probably got the lock many
            times before letting other threads get it, even if those other threads started to wait before the actual
            thread releases the lock. Fairness is not a strong point of this lock.
            </summary>
        </member>
        <member name="T:fx.Collections.SpinReaderWriterLock">
            <summary>
            A reader writer lock that uses SpinWait if it does not have the lock. If the locks are held for to much time,
            this is CPU consuming. In my general tests, it is about 20 times faster than ReaderWriterLockSlim class and two
            times faster than the YieldReaderWriterLock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLock.ReadLock">
            <summary>
            Acquires a read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLock.UpgradeableLock">
            <summary>
            Acquires a upgradeable read lock that must be used in a using clause.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLock.WriteLock">
            <summary>
            Acquires a write lock that must be used in a using clause. If you are using a UpgradeableLock use the
            Upgrade method of the YieldUpgradeableLock instead or you will cause a dead-lock.
            </summary>
        </member>
        <member name="T:fx.Collections.SpinReaderWriterLockSlim">
            <summary>
            A "real slim" reader writer lock. Many readers can read at a time and only one writer is allowed. Reads can be
            recursive, but a try to a recursive write will cause a dead-lock. Note that this is a struct, so don't assign it
            to a local variable.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.EnterReadLock">
            <summary>
            Enters a read lock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.ExitReadLock">
            <summary>
            Exits a read-lock. Take care not to exit more times than you entered, as there is no check for that.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.EnterUpgradeableLock">
            <summary>
            Enters an upgradeable lock (it is a read lock, but it can be upgraded). Only one upgradeable lock is allowed
            at a time.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.UncheckedExitUpgradeableLock">
            <summary>
            Exits a previously obtained upgradeable lock without verifying if it was upgraded or not.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.ExitUpgradeableLock(System.Boolean)">
            <summary>
            Exits a previously entered upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.UncheckedUpgradeToWriteLock">
            <summary>
            upgrades to write-lock. You must already own a Upgradeable lock and you must first exit the write lock then
            the Upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.UpgradeToWriteLock(System.Boolean@)">
            <summary>
            upgrades to write-lock. You must already own a Upgradeable lock and you must first exit the write lock then
            the Upgradeable lock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.UncheckedExitUpgradedLock">
            <summary>
            Releases the Upgradeable lock and the upgraded version of it (the write lock) at the same time. Releasing
            the write lock and the upgradeable lock has the same effect, but it's slower.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.EnterWriteLock">
            <summary>
            Enters write-lock.
            </summary>
        </member>
        <member name="M:fx.Collections.SpinReaderWriterLockSlim.ExitWriteLock">
            <summary>
            Exits write lock. Take care to exit only when you entered, as there is no check for that.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Strings.Arg_ArrayPlusOffTooSmall">
            <summary>
              Looks up a localized string similar to Destination array is not long enough to copy all the items in the collection. Check array index and length..
            </summary>
        </member>
        <member name="P:System.Strings.Arg_HTCapacityOverflow">
            <summary>
              Looks up a localized string similar to Capacity has overflowed..
            </summary>
        </member>
        <member name="P:System.Strings.Arg_KeyNotFoundWithKey">
            <summary>
              Looks up a localized string similar to The given key &apos;{0}&apos; was not present in the dictionary..
            </summary>
        </member>
        <member name="P:System.Strings.Argument_AddingDuplicateWithKey">
            <summary>
              Looks up a localized string similar to An item with the same key has already been added. Key: {0}.
            </summary>
        </member>
        <member name="P:System.Strings.Argument_InvalidOffLen">
            <summary>
              Looks up a localized string similar to Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection..
            </summary>
        </member>
        <member name="P:System.Strings.ArgumentOutOfRange_Count">
            <summary>
              Looks up a localized string similar to Count must be positive and count must refer to a location within the string/array/collection..
            </summary>
        </member>
        <member name="P:System.Strings.ArgumentOutOfRange_Index">
            <summary>
              Looks up a localized string similar to Index was out of range. Must be non-negative and less than the size of the collection..
            </summary>
        </member>
        <member name="P:System.Strings.ArgumentOutOfRange_ListInsert">
            <summary>
              Looks up a localized string similar to Index must be within the bounds of the List..
            </summary>
        </member>
        <member name="P:System.Strings.ArgumentOutOfRange_NeedNonNegNum">
            <summary>
              Looks up a localized string similar to Non-negative number required..
            </summary>
        </member>
        <member name="P:System.Strings.CopyTo_ArgumentsTooSmall">
            <summary>
              Looks up a localized string similar to Destination array is not long enough to copy all the items in the collection. Check array index and length..
            </summary>
        </member>
        <member name="P:System.Strings.Create_TValueCollectionReadOnly">
            <summary>
              Looks up a localized string similar to The specified TValueCollection creates collections that have IsReadOnly set to true by default. TValueCollection must be a mutable ICollection..
            </summary>
        </member>
        <member name="P:System.Strings.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>
              Looks up a localized string similar to Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection&apos;s state is no longer correct..
            </summary>
        </member>
        <member name="P:System.Strings.InvalidOperation_EnumEnded">
            <summary>
              Looks up a localized string similar to Enumeration already finished..
            </summary>
        </member>
        <member name="P:System.Strings.InvalidOperation_EnumFailedVersion">
            <summary>
              Looks up a localized string similar to Collection was modified; enumeration operation may not execute..
            </summary>
        </member>
        <member name="P:System.Strings.InvalidOperation_EnumNotStarted">
            <summary>
              Looks up a localized string similar to Enumeration has not started. Call MoveNext..
            </summary>
        </member>
        <member name="P:System.Strings.InvalidOperation_EnumOpCantHappen">
            <summary>
              Looks up a localized string similar to Enumeration has either not started or has already finished..
            </summary>
        </member>
        <member name="P:System.Strings.NotSupported_KeyCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a key collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:System.Strings.NotSupported_ValueCollectionSet">
            <summary>
              Looks up a localized string similar to Mutating a value collection derived from a dictionary is not allowed..
            </summary>
        </member>
        <member name="P:System.Strings.ReadOnly_Modification">
            <summary>
              Looks up a localized string similar to The collection is read-only.
            </summary>
        </member>
    </members>
</doc>
